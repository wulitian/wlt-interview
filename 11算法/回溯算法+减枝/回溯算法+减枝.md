#### 回溯算法+减枝

##### 回溯算法
回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。
解决一个回溯问题，实际上就是一个决策树的遍历过程，一般来说我们需要解决三个问题：
1、路径：也就是已经做出的选择。
2、选择列表：也就是你当前可以做的选择。
3、结束条件：也就是到达决策树底层，无法再做选择的条件。
回溯算法模板：在递归之前做选择，在递归之后撤销选择

##### 键枝
上面说到回溯算法就像一颗N叉树，底下有很多的子节点（树枝），比如我们将一个数组从小到大排序后,第二个数已经大于要求的结果，
那么它后面的数一定也大于要求结果，所以没必要再往下进行遍历，直接剪掉这个枝（跳出循环），进行下一轮搜索。
所以一般回溯算法离不开剪枝，搜索问题一般复杂度较高，把候选数组排个序。能剪枝就尽量剪枝。

##### 解题模版
```
// 1.路径：也就是已经做出的选择。
// 2.选择列表：也就是你当前可以做的选择。
// 3.结束条件：也就是到达决策树底层，无法再做选择的条件。
let backtracking=(路径，选择列表) =>{
    if (满足结束条件)) {
        存放路径;
        return;
    }
    for (选择：路径，选择列表) {
        做出选择；
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

##### 剪枝函数
1.用约束条件剪除得不到的可行解的子树
2.用目标函数剪取得不到的最优解的子树

##### 回溯法的一般步骤：
1.设置初始化的方案（给变量赋初始值，读入已知数据等）
2.变换方式去试探，若全部试完侧转（7）
3.判断此法是否成功（通过约束函数），不成功则转（2）
4.试探成功则前进一步再试探
5.正确方案还是未找到则转（2）
6.以找到一种方案则记录并打印
7.退回一步（回溯），若未退到头则转（2）
8.已退到头则结束或打印无解