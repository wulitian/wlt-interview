// 推荐多样性需要从多个列表中选择元素，一次性要返回 N 屏数据（窗口数量），每屏展示 K 个元素（窗口大小），选择策略：
// 各个列表元素需要做穿插处理，即先从第一个列表中为每屏选择一个元素，再从第二个列表中为每屏选择一个元素，依次类推
// 每个列表的元素尽量均分为 N 份，如果不够 N 个，也要全部分配完，参考样例图：
// （1）从第一个列表中选择 4 条 0 1 2 3，分别放到 4 个窗口中
// （2）从第二个列表中选择 4 条 10 11 12 13，分别放到 4 个窗口中
// （3）从第三个列表中选择 4 条 20 21 22 23，分别放到 4 个窗口中
// （4）再从第一个列表中选择 4 条 4 5 6 7，分别放到 4 个窗口中
// （5）再从第一个列表中选择，由于数量不足 4 条，取剩下的 2 条，放到 窗口1 和 窗口2
// （6）再从第二个列表中选择，由于数量不足 4 条并且总的元素数达到窗口要求，取 18 19 放到 窗口3 和 窗口4
// 输入：4
// 输入：7
// 输入：0 1 2 3 4 5 6 7 8 9
// 输入：10 11 12 13 14 15 16 17 18 19
// 输入：20 21 22 23 24 25 26 27 28 29
// 输出：0 10 20 4 14 24 8 1 11 21 5 15 25 9 2 12 22 6 16 26 18 3 13 23 7 17 27 19
function getRes(windowNum, size, arr) {
    let level = 0;
    let idx = 0;
    let win = new Array(windowNum * size);
    while (idx < win.length) {
        let flag = false;
        for (let i = 0; i < windowNum; i++) {
            win[idx++] = arr[level].shift()
            if (arr[level].length === 0 && arr.length > 1) {
                arr.splice(level, 1);
                level %= arr.length;
                flag = true;
            }
            console.log(win)
        }
        if (!flag) {
            level = (level + 1) % arr.length;
        }
    }
    return win;
}

console.log(getRes(4, 7, [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [10, 11, 12, 13, 14, 15, 16, 17, 18, 19], [20, 21, 22, 23, 24, 25, 26, 27, 28, 29]]))
