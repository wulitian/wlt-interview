#### 前端工程化

#### 当新入职一家公司时，如何快速搭建开发环境并让应用跑起来
查看是否有 CI/CD，如果有跟着 CI/CD 部署的脚本跑命令
查看是否有 dockerfile，如果有跟着 dockerfile 跑命令
查看 npm scripts 中是否有 dev/start，尝试 npm run dev/npm start
查看是否有文档，如果有跟着文档走。为啥要把文档放到最后一个？原因你懂的
但即便是十分谨慎，也有可能遇到以下几个叫苦不迭、浪费了一下午时间的坑:
前端有可能在本地环境启动时需要依赖前端构建时所产生的文件，所以有时需要先正常部署一遍，再试着按照本地环境启动 (即需要先 npm run build 一下，再 npm run dev/npm start)。(比如，一次我们的项目 npm run dev 时需要 webpack DllPlugin 构建后的东西）
别忘了设置环境变量或者配置文件 (.env/consul/k8s-configmap)
因此，设置一个少的 script，可以很好地避免后人踩坑，更重要的是，可以避免后人骂你，
此时可设置 script hooks，如 prepare、postinstall 自动执行脚本，来完善该项目的基础设施
{
    "scripts": {
    "start": "npm run dev",
    "config": "node assets && node config",
    "build": "webpack",
    // 设置一个钩子，在 npm install 后自动执行，此处有可能不是必须的
    "prepare": "npm run build",
    "dev": "webpack-dev-server --inline --progress"
    }
}
#### npm start和npm run dev区别
npm start 和 npm run dev 是两个不同的命令，它们的作用是在项目中启动服务器。
npm start 通常是用于生产环境中，它会运行项目中的start脚本，并启动项目。
而 npm run dev 则通常用于开发环境中，它会运行项目中的 dev 脚本，并启动项目。 dev 脚本通常包含了一些开发环境下的特殊配置，如代码热重载，报错信息友好等。
因此，在开发环境中使用 npm run dev 可以让您方便的调试和开发项目，而在生产环境中使用 npm start 可以确保项目的正常运行。
#### 网站性能优化都有哪些点
1. 资源加载优化
- 衡量性能指标
Lab Data, 在规范的特定条件下，对 Web 应用的各项指标进行评估，典型工具如谷歌的 lighthouse
RUM，基于真实用户的性能指标监控，包括 FCP，FID，CLS 等，参考 https://web.dev/user-centric-performance-metrics/
瀑布图，借助 performance API 记录整个站点和各个资源的加载时长
- 优化资源大小(字节数)
评估各资源的用途并评估是否可以直接移除
通过压缩技术(minimize 和 compress)减少文本类资源(CSS,JavaScript,HTML)大小
选择合适的图片格式、裁剪图片、懒加载图片等，通过 picture 标签响应式地返回图片，参考 https://www.jianshu.com/p/607567e488fc
预加载和长期缓存字体，参考 https://web.dev/optimize-webfont-loading/
- 减少 HTTP 请求次数
合并文本资源，比如使用 webpack 这样的 bundle 技术
合并图片资源，比如雪碧图
内联内容较小的资源到 html 中，比如 data url
- 善用 HTTP 缓存
本地缓存命中顺序，内存缓存 => Service Worker 缓存 => HTTP 缓存(磁盘缓存) => HTTP/2 Push 缓存，参考 https://calendar.perfplanet.com/2016/a-tale-of-four-caches/
https://web.dev/http-cache/
- 优化 JavaScript
JavaScript 的处理过程：下载(fetch) => 解压 => 解析(代码转换为 AST) => 编译(AST 转换为字节码) => 执行
死代码消除(Tree Shaking)，减小总体传输文件大小
Code Spliting + 基于路由的按需加载，减小首次渲染的传输文件大小
- 优化首次渲染路径
渲染路径: DOM 树构建 => CSSOM 树构建 => Render Tree 构建 => 样式计算 => 布局 => 绘制位图 => 合成图层
通过媒体查询避免首次渲染时加载不必要的 CSS 文件
将对页面结构无影响的 JS 文件标记为 async 和 defer，避免阻塞 html 解析
2. 渲染优化
使用 requestAnimationFrame 代替 setTimeout 和 setInterval 来更新视图，减少卡顿
将计算密集型的 JavaScript 代码移动到 Web Worker 中执行，避免占用主线程
使用复杂度更低、class 风格的 CSS 选择器；减少频繁变动的 CSS 样式的影响元素个数
使用性能更高的 flex 布局代替 float 布局
避免对 offsetHeight 等 dom 属性的频繁访问，导致重绘和重排操作队列的频繁同步执行
在 performance profiling 之后，将频繁变动的动画部分所属的 dom 元素标记为 will-change，独立构成一个图层
#### 你们的前端代码上线部署一次需要多长时间，需要人为干预吗
更短的部署时间，更少的人为干预，更有利于敏捷开发
#### 有没有用 npm 发布过 package，如何发布
注册 npm 账号 https://www.npmjs.com/
本地通过命令行 npm login 登陆
进入到项目目录下（与 package.json 同级），在 package.json 中指定发布文件、文件夹
{
"name": "pkg-xxx",
"version": "0.0.1",
"main": "lib/index.js",
"module": "esm/index.js",
"typings": "types/index.d.ts",
"files": [
    "CHANGELOG.md",
    "lib",
    "esm",
    "dist",
    "types",
],
...
}
执行 npm publish --registry=https://registry.npmjs.org/ 即可发布
#### js 代码压缩 minify 的原理是什么
通过 AST 分析，根据选项配置一些策略，来生成一颗更小体积的 AST 并生成代码。
目前前端工程化中使用 terser(opens new window) 和 swc(opens new window) 进行 JS 代码压缩，他们拥有相同的 API。
常见用以压缩 AST 的几种方案如下:
去除多余字符: 空格，换行及注释
// 对两个数求和
function sum (a, b) {
    return a + b;
}
此时文件大小是 62 Byte， 一般来说中文会占用更大的空间。
多余的空白字符会占用大量的体积，如空格，换行符，另外注释也会占用文件体积。当我们把所有的空白符合注释都去掉之后，代码体积会得到减少。
去掉多余字符之后，文件大小已经变为 30 Byte。 压缩后代码如下:
function sum(a,b){return a+b}
替换掉多余字符后会有什么问题产生呢？
有，比如多行代码压缩到一行时要注意行尾分号。
压缩变量名：变量名，函数名及属性名
function sum (first, second) {
return first + second;  
}
如以上 first 与 second 在函数的作用域中，在作用域外不会引用它，此时可以让它们的变量名称更短。但是如果这是一个 module 中，sum 这个函数也不会被导出呢？那可以把这个函数名也缩短。
// 压缩: 缩短变量名
function sum (x, y) {
    return x + y;  
}
// 再压缩: 去除空余字符
function s(x,y){return x+y}
在这个示例中，当完成代码压缩 (compress) 时，代码的混淆 (mangle) 也捎带完成。 但此时缩短变量的命名也需要 AST 支持，不至于在作用域中造成命名冲突。
解析程序逻辑：合并声明以及布尔值简化
通过分析代码逻辑，可对代码改写为更精简的形式。
合并声明的示例如下：
// 压缩前
const a = 3;
const b = 4;
// 压缩后
const a = 3, b = 4;
布尔值简化的示例如下：
// 压缩前
!b && !c && !d && !e
// 压缩后
!(b||c||d||e)
解析程序逻辑: 编译预计算
在编译期进行计算，减少运行时的计算量，如下示例:
// 压缩前
const ONE_YEAR = 365 * 24 * 60 * 60
// 压缩后
const ONE_YAAR = 31536000
以及一个更复杂的例子，简直是杀手锏级别的优化。
// 压缩前
function hello () {
    console.log('hello, world')
}
hello()
// 压缩后
console.log('hello, world')
#### 权限设计中的 RABC 是指什么
1. 模型是一种常用的权限控制模型，用于管理和控制用户对系统资源的访问权限。在 RBAC 模型中，访问权限是通过角色而不是直接与用户关联来进行管理的。
用户（User）：用户代表系统中的实体，可以是个人用户或其他应用程序。用户通过被分配角色来获得相应的权限，从而决定其在系统中能够执行的操作。
角色（Role）：角色代表了一组相关权限的集合，通常与用户的职能、责任或角色相对应。每个角色拥有特定的权限，定义了该角色所能执行的操作。
权限（Permission）：权限是指用户对系统资源的访问能力。它可以是操作级别的，如读取、写入、删除等，也可以是对象级别的，如访问特定文件或数据库。
2. RBAC工作原理
   把权限赋予角色，再把角色赋予用户，用户就拥有了角色所对应的权限。用户拥有的权限等于他所有的角色持有权限之和。
3. RBAC的几种模型
默认为RBAC0
- RBAC1 在 RBAC0 的基础上，进行了 角色分层。通过给角色划分等级，每个等级拥有不同的权限，从而实现了更细粒度的权限管理。这种角色的分层让权限的分配更加灵活，可以根据具体需求来调整角色等级和相应的权限。
- RBAC2 RBAC2 在 RBAC0 的基础上增加了 RBAC 的 约束模型。具体来说，这些限制可以分成两类，即静态职责分离（SSD）和动态职责分离（DSD）。通过这些约束模型，RBAC2 能够更好地保证权限的安全性和稳定性。
  静态职责分离（SSD） 主要是对用户、角色和权限三者之间增加了一些限制，例如互斥角色和基数约束。在 SSD 中，一些特定的角色不能被分配给同一个用户。例如，同一用户不能被分配 “管理员” 和 “普通用户” 这两个互斥角色。另外，对于用户拥有的角色数量也有限制，即一个用户拥有的角色是有限的。在一些场景中，例如公司或组织的实际运营中，不同的职位或角色之间具有一定的排他性，不能同时由同一人担任。通过 SSD，我们可以保证这种排他性得以实现。
  动态职责分离（DSD） 主要是在会话和角色之间增加限制。具体来说，DSD 可以动态地约束用户拥有的角色。例如，一个用户可以有多个角色，但是在一次会话中只能激活一个角色。这种动态的约束可以防止用户在会话中同时激活多个角色，从而保证系统的安全性。
- RBAC3 是 RBAC2 和RBAC1的合集，所以它 既包含了角色分层，也包括了可以增加的各种约束。因此，RBAC3是这四种模型中最为全面和复杂的权限管理模型。可以实现更为精细和安全的权限管理。
#### 如何进行代码质量检测
eslint代码编写过程中的规范做好限制，提交前运行eslint,并在之前运行单元测试文件，合理地单元测试可以控制代码质量，提交后代码组长审核，之后集成测试。
平时关注一下各个包是否有bug如果有第一时间升级对应的包
#### performance API 中什么指标可以衡量首屏时间
// 首屏时间
timingInfo.domComplete - timingInfo.fetchStart;
#### 什么是 Open Graph 协议，用来做什么
Open Graph 协议可以让任何一个网页集成到社交图谱中。例如，facebook 就是一种社交图谱(social graph)。 一旦一个网页按照该协议进行集成，这个网页就像是社交图谱的一个节点，例如，你的网页集成了 open graph 协议， 按照协议加入了网页的标题，描述以及图片信息等等，那么你在 facebook 中分享这个网页的时候，facebook 就会按照 你定义的内容来展示这个网页。
这个协议其实很简单，主要是通过在 html 中加入一些元数据（meta）标签来实现，例如 在 head 中加入 meta 标签，property 是以 og(open graph)开头, 后面跟着具体属性，content 里面是属性的值， 下面这段描述的就是一个类型为 video.movie，标题为 The rock，以及 url 和图片信息。这个例子就可以当做是 为 https://www.imdb.com/title/tt0117500/ 实现了 Open Graph 协议、
```
<html prefix="og: http://ogp.me/ns#">
<head>
<title>The Rock (1996)</title>
<meta property="og:title" content="The Rock" />
<meta property="og:type" content="video.movie" />
<meta property="og:url" content="http://www.imdb.com/title/tt0117500/" />
<meta property="og:image" content="http://ia.media-imdb.cimg/rock.jpg" />
...
</head>
...
</html> 
```
结论： 这个协议主要是 Facebook 提出来的，为了更好的展示用户分享的网页的内容，实现这个协议，有助于 SEO 优化，告诉 google 该网页有哪些内容，以及关键词等。
#### 简述你们前端项目中资源的缓存配置策略
非工程化项目
|  \             |  html                         | css和js               |	图片    |
|  ------------  |  ---------------------------- | -------------------- |--------  |
| 频率            | 可能会频繁更改，需要每次都询问。    | 可能每月修改           | 几乎不变   |
| Cache-Control  | private, no-cache             | Public, max-age=2592000 (一个月) | Public, max-age=31536000 (一年)，stale-while-revalidate=86400 |
| 使缓存失效       | 每次都要询问，确保最新            | 自动过期或改名字（hash值）        | 自动过期或改名字（hash值） |

现代工程化架构下的最佳缓存策略有所不同
|  \             |  html                         | css和js               |	图片    |
|  ------------  |  ---------------------------- | -------------------- |--------  |
| 频率            | 可能会频繁更改，需要每次都询问。    | 可能每月修改           | 几乎不变   |
| Cache-Control  | private, no-cache             | Public, max-age=31536000 (一年甚至永久) | Public, max-age=31536000 (一年甚至永久)，stale-while-revalidate=86400 |
| 使缓存失效       | 每次都要询问，确保最新            | 改名字（hash值）        |改名字（hash值） |
#### 如何加速 npm install
选择时延低的 registry，需要企业技术基础建设支持
NODE_ENV=production，只安装生产环境必要的包(如果 dep 与 devDep 没有仔细分割开来，工作量很大，可以放弃)
CI=true，npm 会在此环境变量下自动优化
结合 CI 的缓存功能，充分利用 npm cache
使用 npm ci 代替 npm i，既提升速度又保障应用安全性
#### npm i 与 npm ci 的区别是什么
npm ci (6.0 版本以上) 
1。会删除项目中的 node_modules 文件夹； 
2. 会依照项目中的package.json 来安装确切版本的依赖项； 
3. 不像 npm install, npm ci 不会修改你的 package-lock.json 但是它确实期望你的项目中有一个 - package-lock.json 文件 - 如果你没有这个文件， npm ci 将不起作用，此时必须使用 npm install
#### package-lock.json 有什么作用，如果项目中没有它会怎么样，举例说明
正常情况下如果按照semver规范是没有问题的
演示风险过程如下:
pkg 1.2.3: 首次在开发环境安装 pkg 库，为此时最新版本 1.2.3，dependencies 依赖中显示 ^1.2.3，实际安装版本为 1.2.3
pkg 1.19.0: 在生产环境中上线项目，安装 pkg 库，此时最新版本为 1.19.0，满足 dependencies 中依赖 ^1.2.3 范围，实际安装版本为 1.19.0，但是 pkg 未遵从 semver 规范，在此过程中引入了 Breaking Change，如何此时 1.19.0 有问题的话，那生产环境中的 1.19.0 将会导致 bug，且难以调试
而当有了 lock 文件时，每一个依赖的版本号都被锁死在了 lock 文件，每次依赖安装的版本号都从 lock 文件中进行获取，避免了不可测的依赖风险。
pkg 1.2.3: 首次在开发环境安装 pkg 库，为此时最新版本 1.2.3，dependencies 依赖中显示 ^1.2.3，实际安装版本为 1.2.3，在 lock 中被锁定版本号
pkg 1.2.3: 在生产环境中上线项目，安装 pkg 库，此时 lock 文件中版本号为 1.2.3，符合 dependencies 中 ^1.2.3 的范围，将在生产环境安装 1.2.3，完美上线。
#### 刚刚启动了一个服务，如何知道这个服务对应的端口号是多少
在 linux 系统中，我通常通过 ps -aux |grep 服务名
#### 图片防盗链原理是什么
请求头中的 refer 来判断是否屏蔽图片
#### 什么是 XSS 攻击，如何避免
我们可以将这段代码注入到富文本中
```
<script> alert("XSS"); </script>
<img src="https://devtool.tech/notfound.png" onerror="alert('XSS')" /> 
```
存储到后台数据库，查询页面展示会导致弹窗，
通常页面中包含的用户输入内容都在固定的容器或者属性内，以文本的形式展示。
攻击者利用这些页面的用户输入片段，拼接特殊格式的字符串，突破原有位置的限制，形成了代码片段。
攻击者通过在目标网站上注入脚本，使之在用户的浏览器上运行，从而引发潜在风险。
通过 HTML 转义，可以防止 XSS 攻击。但是还有一种情况就是
```
<a href="javascript:alert(&#x27;XSS&#x27;)">跳转...</a>
```
这种也会导致弹窗，所以也需要过滤掉只允许http开头的链接
总结
在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。
在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。
在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。
在标签的 href、src 等属性中，包含 javascript: 等可执行代码。
在 onload、onerror、onclick 等事件中，注入不受控制代码。
在 style 属性和标签中，包含类似 background-image:url("javascript:..."); 的代码（新版本浏览器已经可以防范）。
在 style 属性和标签中，包含类似 expression(...) 的 CSS 表达式代码（新版本浏览器已经可以防范）。
#### 如何查看你们 JS 项目中应采用的 node 版本
packageJson.engines，第三方模块都会有，自己的项目中有可能有
pm2.app[].interpreter，如果采用 pm2 部署，可以查看 interpreter 选项，但不保证该项存在
FROM，如果采用 docker 部署，查看基础镜像 Dockerfile 中 node 的版本号
如果以上方式都不可以，那只有问人了
#### 如何查看 node_modules(某一文件夹) 的体积有多大
du -hd 1 node_modules
#### peerDependency 是为了解决什么问题
避免重复安装
#### semver 指什么，试图解释一下
语义化版本号。版本格式：主版本号.次版本号.修订号
#### optionalDependencies 的使用场景是什么
当一个包是可依赖可不依赖时，可采用 optionalDependencies，但需要在代码中做好异常处理。
#### package-lock.json 与 yarn.lock 有什么区别
package-lock.json把所有的包的依赖顺序列出来，第一次出现的包名会提升到顶层，后面重复出现的将会放入被依赖包的node_modules当中。引起不完全扁平化问题。
yarn.lock锁文件把所有的依赖包都扁平化的展示了出来，对于同名包但是semver不兼容的作为不同的字段放在了yarn.lock的同一级结构中。
#### 什么是浏览器的关键渲染路径
01 DOM
生成 DOM 会从远程下载 Byte，并根据相应的编码 (如 utf8) 转化为字符串，通过 AST 解析为 Token，生成 Node 及最后的 DOM。
02 CSSOM
当解析 CSS 文件时，最终会生成 CSSOM
03 Render Tree
DOM 与 CSSOM 会一起生成 Render Tree，只包含渲染网页所需的节点。
04 Layout
计算每一个元素在设备视口内的确切位置和大小
05 Paint
将渲染树中的每个节点转换成屏幕上的实际像素，这一步通常称为绘制或栅格化
#### 你使用过哪些前端性能分析工具
lighthouse: 可在 chrome devtools 直接使用，根据个人设备及网络对目标网站进行分析，并提供各种建议
webpagetest: 分布式的性能分析工具，可在全球多个区域的服务器资源为你的网站进行分析，并生成相应的报告
#### 在 nginx 中如何配置负载均衡
通过 proxy_pass 与 upstream 即可实现最为简单的负载均衡。如下配置会对流量均匀地导向 172.168.0.1，172.168.0.2 与 172.168.0.3 三个服务器
```
http {
  upstream backend {
      server 172.168.0.1;
      server 172.168.0.2;
      server 172.168.0.3;
  }
  server {
      listen 80;
      location / {
          proxy_pass http://backend;
      }
  }
} 
```
关于负载均衡的策略大致有以下四种种
round_robin: 轮询，nginx 默认的负载均衡策略就是轮询，假设负载三台服务器节点为 A、B、C，则每次流量的负载结果为 ABCABC
weighted_round_robin: 加权轮询，根据关键字 weight 配置权重，如下则平均没来四次请求，会有八次打在 A，会有一次打在 B，一次打在 C
ip_hash: 对每次的 IP 地址进行 Hash，进而选择合适的节点，如此，每次用户的流量请求将会打在固定的服务器上，利于缓存，也更利于 AB 测试等。
least_conn: 选择连接数最少的服务器节点优先负载
#### 前端打包时 cjs、es、umd 模块有何不同
1. cjs (commonjs)commonjs 是 Node 中的模块规范，通过 require 及 exports 进行导入导出 (进一步延伸的话，module.exports 属于 commonjs2)
同时，webpack 也对 cjs 模块得以解析，因此 cjs 模块可以运行在 node 环境及 webpack 环境下的，但不能在浏览器中直接使用。但如果你写前端项目在 webpack 中，也可以理解为它在浏览器和 Node 都支持
cjs 为动态加载，可直接 require 一个变量
2. esm (es module) esm 是 tc39 对于 ESMAScript 的模块话规范，正因是语言层规范，因此在 Node 及 浏览器中均会支持。 它使用 import/export 进行模块导入导出.
esm 为静态导入，正因如此，可在编译期进行 Tree Shaking，减少 js 体积。
- cjs与esm对比
   cjs 模块输出的是一个值的拷贝，esm 输出的是值的引用
   cjs 模块是运行时加载，esm 是编译时加载
3. umd  一种兼容 cjs 与 amd 的模块，既可以在 node/webpack 环境中被 require 引用，也可以在浏览器中直接用 CDN 被 script.src 引入。
这三种模块方案大致如此，部分 npm package 也会同时打包出 commonjs/esm/umd 三种模块化格式，供不同需求的业务使用
#### 什么是前端工程化
前端工程化的主要目标就是解放生产力、提高生产效率。通过制定一系列的规范，借助工具和框架解决前端开发以及前后端协作过程中的痛点和难度问题。
#### 什么是服务器渲染 (SSR)
服务器渲染 (SSR)：将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记"激活"为客户端上完全可交互的应用程序。这个过程可以成为服务端渲染。
优势： 更好的 SEO 更快的内容到达时间 (time-to-content)
#### dependencies 与 devDependencies 有何区别
dependencies字段指定了项目运行所依赖的模块，devDependencies指定项目开发所需要的模块。
当你在软件包目录下执行npm install命令时，dependencies、devDependencies指定的三方软件包均会在node_modules目录下安装，若执行npm install --production命令，则不会安装devDependecies指定的三方软件包。但当软件包作为三方软件包被安装时（npm install $package）,则dependencies指定的软件包会被安装，devDependencies指定指定的软件包不会被安装。
了解dependencies和devDependencies的作用后，我们在开发软件包时，哪些依赖应该放入dependencies，哪些依赖应该放入devDependencies中。
首先我们要明确放入dependencies中的依赖软件包，是我们的项目在生产环境下运行时必须依赖的软件包，其的部分功能或全部功能通常会被打包到我们工程发布的bundles中。而放入devDependencies中软件包是我们的工程在开发时依赖的软件包，通常情况下以下的依赖会被放入devDenpencies中：
格式化代码或错误检查类软件包：esLint、prettier
打包工具及其插件：webpack, gulp, parceljs
babel及其的插件
单元测试类：enzyme, jest
#### npm workspaces 解决了什么问题
多个包难以互相链接
#### 如何为一个项目指定 node 版本号
指定一个项目所需的 node 最小版本，这属于一个项目的质量工程。
如果对于版本不匹配将会报错(yarn)或警告(npm)，那我们需要在 package.json 中的 engines 字段中指定 Node 版本号
{
 "engines": {
  "node": ">=14.0.0"
 }
}
#### 什么是 semver，~1.2.3 与 ^1.2.3 的版本号范围是多少
对于 ~1.2.3 而言，它的版本号范围是 >=1.2.3 <1.3.0
对于 ^1.2.3 而言，它的版本号范围是 >=1.2.3 <2.0.0
#### npm i 某个 package 时会修改 package-lock.json 中的版本号吗？
当 package-lock.json 该 package 锁死的版本号符合 package.json 中的版本号范围时，将以 package-lock.json 锁死版本号为主。
当 package-lock.json 该 package 锁死的版本号不符合 package.json 中的版本号范围时，将会安装该 package 符合 package.json 版本号范围的最新版本号，并重写 package-lock.json
#### package.json 中 main/module/browser/exports 字段有何区别
1. main
main 指 npm package 的入口文件，当我们对某个 package 进行导入时，实际上导入的是 main 字段所指向的文件。main 是 CommonJS 时代的产物，也是最古老且最常用的入口文件。
```
// package.json 内容
{
  name: 'midash',
  main: './dist/index.js'
}
// 关于如何引用 package
const midash = require('midash')
// 实际上是通过 main 字段来找到入口文件，等同于该引用
const midash = require('midash/dist/index.js') 
```
2. module
随着 ESM 且打包工具的发展，许多 package 会打包 N 份模块化格式进行分发，如 antd 既支持 ES，也支持 umd，将会打包两份。
如果使用 import 对该库进行导入，则首次寻找 module 字段引入，否则引入 main 字段。 基于此，许多前端友好的库，都进行了以下分发操作:对代码进行两份格式打包: commonjs 与 es module
module 字段作为 es module 入口
main 字段作为 commonjs 入口
```
{
   name: 'midash',
   main: './dist/index.js',
   module: './dist/index.mjs'
}
// 以下两者等同
import midash from 'midash'
import midash from 'midash/dist/index.mjs'
```
如果你的代码只分发一份 es module 模块化方案，则直接置于 main 字段之中。
3. exports
如果说以上两个是刀剑，那 exports 至少得是瑞士军刀。exports 可以更容易地控制子目录的访问路径，也被称为 export map。
不在 exports 字段中的模块，即使直接访问路径，也无法引用！
```
// package.json
{
  name: 'midash',
  main: './index.js',
  exports: {
    '.': './dist/index.js',
    'get': './dist/get.js'
  }
}
// 正常工作
import get from 'midash/get'
// 无法正常工作，无法引入
import get from 'midash/dist/get' 
```
exports 不仅可根据模块化方案不同选择不同的入口文件，还可以根据环境变量(NODE_ENV)、运行环境(nodejs/browser/electron) 导入不同的入口文件。
```
{
  "type": "module",
  "exports": {
    "electron": {
      "node": {
        "development": {
          "module": "./index-electron-node-with-devtools.js",
          "import": "./wrapper-electron-node-with-devtools.js",
          "require": "./index-electron-node-with-devtools.cjs"
        },
        "production": {
          "module": "./index-electron-node-optimized.js",
          "import": "./wrapper-electron-node-optimized.js",
          "require": "./index-electron-node-optimized.cjs"
        },
        "default": "./wrapper-electron-node-process-env.cjs"
      },
      "development": "./index-electron-with-devtools.js",
      "production": "./index-electron-optimized.js",
      "default": "./index-electron-optimized.js"
    },
    "node": {
      "development": {
        "module": "./index-node-with-devtools.js",
        "import": "./wrapper-node-with-devtools.js",
        "require": "./index-node-with-devtools.cjs"
      },
      "production": {
        "module": "./index-node-optimized.js",
        "import": "./wrapper-node-optimized.js",
        "require": "./index-node-optimized.cjs"
      },
      "default": "./wrapper-node-process-env.cjs"
    },
    "development": "./index-with-devtools.js",
    "production": "./index-optimized.js",
    "default": "./index-optimized.js"
  }
} 
```
#### npm publish 时 npm script 的生命周期
prepublishOnly
prepack
prepare
postpack
publish
postpublish
#### 前端项目每次 npm install 之后需要执行一些处理工作，应该怎么办
使用 npm script 生命周期中的 npm prepare，他将会在发包 (publish) 之前以及装包 (install) 之后自动执行。
如果指向在装包之后自动执行，可使用 npm postinstall
```
{
    "prepare": "npm run build & node packages/husky/lib/bin.js install"
}
{
    "postinstall": "patch-package"
}
```
#### 你是如何保障你们项目质量的
lint
type
test
code review
git hooks
CI
#### 现代前端应用应如何配置 HTTP 缓存机制
文件路径中带有 hash 值：一年的强缓存。因为该文件的内容发生变化时，会生成一个带有新的 hash 值的 URL。前端将会发起一个新的 URL 的请求。配置响应头 Cache-Control: public,max-age=31536000,immutable
文件路径中不带有 hash 值：协商缓存。大部分为 public 下文件。配置响应头 Cache-Control: no-cache 与 etag/last-modified
但是当处理永久缓存时，切记不可打包为一个大的 bundle.js，此时一行业务代码的改变，将导致整个项目的永久缓存失效，此时需要按代码更新频率分为多个 chunk 进行打包，可细粒度控制缓存。
webpack-runtime: 应用中的 webpack 的版本比较稳定，分离出来，保证长久的永久缓存
react/react-dom: react 的版本更新频次也较低
vendor: 常用的第三方模块打包在一起，如 lodash，classnames 基本上每个页面都会引用到，但是它们的更新频率会更高一些。另外对低频次使用的第三方模块不要打进来
pageA: A 页面，当 A 页面的组件发生变更后，它的缓存将会失效
pageB: B 页面
echarts: 不常用且过大的第三方模块单独打包
mathjax: 不常用且过大的第三方模块单独打包
jspdf: 不常用且过大的第三方模块单独打包
#### 引入 BFF 层的优势在哪里
BFF 全称 Backend For Frontend，一般指在前端与服务器端搭建一层由前端维护的 Node Server 服务，具有以下好处
数据处理。对数据进行校验、清洗及格式化。使得数据更与前端契合
数据聚合。后端无需处理大量的表连接工作，第三方接口聚合工作，业务逻辑简化为各个资源的增删改查，由 BFF 层聚合各个资源的数据，后端可集中处理性能问题、监控问题、消息队列等
权限前移。在 BFF 层统一认证鉴权，后端无需做权限校验，后端可直接部署在集群内网，无需向外网暴露服务，减少了后端的服务度。
但其中也有一些坏处，如以下
引入复杂度，新的 BFF 服务需要一套基础设施的支持，如日志、异常、部署、监控等
#### 同一页面三个组件请求同一个 API 发送了三次请求，如何优化
```js
const fetchUser = (id) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log("Fetch: ", id);
      resolve(id);
    }, 5000);
  });
};
const cache = {};
const cacheFetchUser = (id) => {
  if (cache[id]) {
    return cache[id];
  }
  cache[id] = fetchUser(id);
  return cache[id];
};
cacheFetchUser(3).then((id) => console.log(id))
cacheFetchUser(3).then((id) => console.log(id))
cacheFetchUser(3).then((id) => console.log(id))
// Fetch:  3
// 3
// 3
// 3 
```
#### 如何压缩前端项目中 JS 的体积
1. terser(opens new window) 或者 uglify(opens new window)，及流行的使用 Rust 编写的 swc 压缩混淆化 JS。
2. gzip 或者 brotli 压缩，在网关处(nginx)开启
3. 使用 webpack-bundle-analyzer 分析打包体积，替换占用较大体积的库，如 moment -> dayjs
4. 使用支持 Tree-Shaking 的库，对无引用的库或函数进行删除，如 lodash -> lodash/es
5. 对无法 Tree Shaking 的库，进行按需引入模块，如使用 import Button from 'antd/lib/Button'，此处可手写 babel-plugin 自动完成，但不推荐
6. 使用 babel (css 为 postcss) 时采用 browserlist，越先进的浏览器所需要的 polyfill 越少，体积更小
7. code spliting，路由懒加载，只加载当前路由的包，按需加载其余的 chunk，首页 JS 体积变小 (PS: 次条不减小总体积，但减小首页体积)
8. 使用 webpack 的 splitChunksPlugin，把运行时、被引用多次的库进行分包，在分包时要注意避免某一个库被多次引用多次打包。此时分为多个 chunk，虽不能把总体积变小，但可提高加载性能 (PS: 此条不减小总体积，但可提升加载性能)
压缩的具体操作
1. 去除多余字符，eg：空格，换行、注释
2. 压缩变量名，函数名、属性名
3. 使用更简单的表达，eg：合并声明、布尔值简化
#### 你们项目中使用了哪些依赖/第三方库
lodash axios echarts file-saver patch-package qs sortablejs vue-clipboard2 xlsx watermark-dom
#### 如何禁止打开浏览器控制台
使用开源项目https://github.com/AEPKILL/devtools-detector
#### 如何提高首屏渲染时间？
1. 对于 pv 量比较高的页面，比如 b 站等流量图也比较大的，采用 ssr 采用 ssr 如何优化性能
性能瓶颈在于 react-dom render/hydrate 和 server 端的 renderToString
尽量减少 dom 结构， 采用流式渲染，jsonString 一个对象，而不是 literal 对象
server 去获取数据
不同情况不同分析，减少主线程阻塞时间
减少不必要的应用逻辑在服务端运行
2. 减少依赖和包的体积
利用 webpack 的 contenthash 缓存
重复依赖包处理，可以采用 pnpm
采用 code splitting，减少首次请求体积
减少第三方依赖的体积
3. FP (First Paint) 首次绘制 FCP (First Contentful Paint) 首次内容绘制 LCP (Largest Contentful Paint) 最大内容渲染 DCL (DomContentloaded) FMP(First Meaningful Paint) 首次有效绘制 L (onLoad) TTI (Time to Interactive) 可交互时间 TBT (Total Blocking Time) 页面阻塞总时长 FID (First Input Delay) 首次输入延迟 CLS (Cumulative Layout Shift) 累积布局偏移 SI (Speed Index) 一些性能指标可以监控性能
4. 网络 prefetch cdn
#### core-js 是做什么用的？
core-js(opens new window) 是关于 ES 标准最出名的 polyfill，polyfill 意指当浏览器不支持某一最新 API 时，它将帮你实现，中文叫做垫片。
由于垫片的存在，打包后体积便会增加，所需支持的浏览器版本越高，垫片越少，体积就会越小。
而 core-js 的伟大之处是它包含了所有 ES6+ 的 polyfill，并集成在 babel 等编译工具之中
core-js 已集成到了 babel 之中，你可以使用 @babel/preset-env 或者 @babel/polyfill 进行配置，详见文档 core-js(opens new window)。通过配置，babel 编译代码后将会自动包含所需的 polyfill
#### 如何处理白屏错误页的监控的？
排查兼容性。大部分原因是因为低端机型/浏览器低版本 polyfill 的问题导致报错
排查网络。js 是否下载成功 cdn 是否生效
做 js 错误上报。分析是否存在代码缺陷
做重试逻辑/诱导用户重试
Error Boundry 避免整页崩溃。限制在组件级别
#### 简述 npm script 的生命周期
在 npm 中，使用 npm scripts 可以组织整个前端工程的工具链。
```
{
  start: 'serve ./dist',
  build: 'webpack',
  lint: 'eslint'
} 
```
除了可自定义 npm script 外，npm 附带许多内置 scripts，他们无需带 npm run，可直接通过 npm <script> 执行
当我们执行任意 npm run 脚本时，将自动触发 pre/post 的生命周期。
当手动执行 npm run abc 时，将在此之前自动执行 npm run preabc，在此之后自动执行 npm run postabc。
```
// 自动执行
npm run preabc
npm run abc
// 自动执行
npm run postabc 
```
patch-package(opens new window) 一般会放到 postinstall 中。(patch-package对工程打补丁会对比当前与之前版本的diff生成patch文件)
```
{
  postinstall: "patch-package";
} 
```
而发包的生命周期更为复杂，当执行 npm publish，将自动执行以下脚本。
prepublishOnly: 最重要的一个生命周期。
prepack
prepare
postpack
publish
postpublish
当然你无需完全记住所有的生命周期，如果你需要在发包之前自动做一些事情，如测试、构建等，请在 prepulishOnly 中完成。
```
{
     prepublishOnly: "npm run test && npm run build";

} 
```
#### npm script一个最常用的生命周期
prepare
npm install 之后自动执行
npm publish 之前自动执行
```
{
  prepare: "husky install";
} 
```
npm script 钩子的风险
假设某一个第三方库的 npm postinstall 为 rm -rf /，那岂不是又很大的风险?
```
{
    postinstall: "rm -rf /";
}
```
实际上，确实有很多 npm package 被攻击后，就是通过 npm postinstall 自动执行一些事，比如挖矿等。
如果 npm 可以限制某些库的某些 hooks 执行，则可以解决这个问题。
#### 如何检测出你们安装的依赖是否安全

#### 请简述下 eslint 的作用
#### 在项目中，如何平滑升级 npm 包
#### 请描述 node_modules 的目录结构(拓扑结构)
#### npm 第三方库需要提交 lockfile 吗
#### 请问什么是 CICD
#### 如何使用 docker 部署前端
#### pnpm 有什么优势
#### 浏览器中如何使用原生的 ESM
#### 如何将 CommonJS 转化为 ESM
#### 如何对 npm package 进行发包
#### 什么是 AST，及其应用
#### 简述 browserslist 的意义
#### 简述 bundless 的优势与不足
#### 简述 npm cache
#### 如何修复某个 npm 包的紧急 bug
#### 前端如何进行高效的分包
#### 前端如何对分支环境进行部署
#### vite 中是如何处理 new URL 资源的
#### 在 babel 编译为低版本 ES 时，为何能够编译可选链之类语法，但无法编译 API
#### 前端如何进行多分支部署
#### 你如何看待 serverless
#### 如何为你们的前端项目选择状态管理器
#### 你有没有重客户端状态前端应用的经验
#### 什么是安全的正则表达式
#### JWT 的原理是什么
#### 如何确认你们项目是否依赖某一个依赖项
#### 当你引入某一个依赖项时，你引入的是该依赖下的哪一个文件
#### 如何正确得知某张图片的 MIME 格式
#### npm 执行命令传递参数时，为何需要双横线
#### http client 中如何得知已接收完所有响应数据
#### git hooks 原理是什么
#### babel 的原理
babel 是 JavaScript 编译器，它能让开发者在开发过程中，直接使用各类方言(如 ts jsx)或新的语法特性，而不需要考虑运行环境，因为 babel 可以做到按需转换为低版本支持的代码；babel 内部原理是将 JS 代码转换为 AST，对 AST 应用各种插件进行处理，最终输出编译后的 JS 代码
#### babel 编译流程
解析阶段：babel 默认使用的是 @babel/parser 将代码转换为 AST。解析一般分为两个阶段：词法分析和语法分析。
词法分析：对输入的字符序列做标记化(tokenization)操作
语法分析：处理标记与标记之间的关系，最终形成一颗完整的 AST 结构
转换阶段：babel 使用的是 @babel/traverse 提供的方法对 AST 进行深度优先遍历，调用插件对关注节点的处理函数，按需对 AST 节点进行增删改操作
生成阶段：babel 默认使用的是 @babel/generator 将上一阶段处理后的 AST 转换为代码字符串

