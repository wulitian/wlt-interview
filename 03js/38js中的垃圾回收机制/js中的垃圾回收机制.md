# js中的垃圾回收机制

#### 定义

js是自动分配内存，在不使用时周期性释放内存，因为自动分配这种机制，导致如果操作不当会导致内存泄漏。

#### 回收算法

##### 标记清理

1. 步骤：
- 变量进入上下文会加上标记，证明其存在该上下文。

- 将所有在上下文中的变量以及上下文中被访问引用的变量标记去掉，表明这些变量活跃有用。

- 在此之后再被加上标记的变量标记为准备删除的变量，因为上下文中的变量已经无法访问它们。

- 执行内存清理，销毁带标记的所有非活跃值并回收之前被占用的内存。

2. 缺点：

- 由于是从根对象(全局对象)开始查找，对于那些无法从根对象查询到的对象都将被清除。

- 回收后会形成内存碎片，影响后面申请大的连续内存空间。

##### 引用计数清理

1. 步骤

- 声明一个变量，赋予它一个引用值时，计数+1；

- 同一个值被赋予另外一个变量时，引用+1；

- 保存对该值引用的变量被其他值覆盖，引用-1；

- 引用为0，回收内存

2. 缺点：循环引用问题

##### nodejs v8回收机制

1. 定义： 将内存分为新生代（young generation）和老生代（tenured generation），新生代为存活时间较短的对象，老生代为存活时间较长或者常驻内存的变量。

2. v8内存限制

- 64位操作系统只能使用1.4G（1464）内存。

- 32位操作系统只能使用0.7G（732）内存。

- 新生代内存占用为零头64位为64M，32位为32M。

3. 内存分配

分为新生代与老生代，并且占用的内存就是V8整体的大小。

4. 内存调整
Node进程启动时通过设置--max-old-space-size来调整老生代最大空间和--max-new-space-size来调整新生代最大空间。

5. 新生代使用垃圾回收算法

Scanvenge是一种复制形式的垃圾回收算法，主要特点是将新生代内存一分为二一半分配赋值对象from，一般为空闲对象to
这种方式虽然内存变小了但是操作比较简单只需要复制就可以完成，典型的空间换时间。主要操作是v8检测from中存活的对象将存活的对象复制到to中，同时清理from中失活的对象，之后在下一次清理时from就会变成之前的to,to会变成之前的from。当一个对象多次复制依然存活就会晋升为老生代。晋升的条件是一个对象经历过Scanvenge，to空间超过25%。

6. 老生代使用得当垃圾回收算法

Mark-Sweep&Mark-Compact算法分别为标记清除与标记整理清除

V8标记阶段会遍历所有老生代对象进行存活对象的标记，之后会将所有未标记的老生代对象全部回收。缺点是这种方式会导致内存不连续，如果来了一个大对象碎片空间不足以存储这个大对象。
标记整理清除就是将存活的对象移动到一端后将失活的对象清理掉，缺点就是会产生卡顿。速度最慢。
在v8老生代清除算法中主要使用标记清理，只有在空间不足以对新生代中晋升过来的对象进行分配时，才会使用标记整理清除算法进行回收。为了弥补卡顿使用Incremental Marking算法，增量标记算法。将原有的全量标记分步执行，卡顿时间减少到1/6


