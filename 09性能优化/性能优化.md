# 性能优化

#### 性能优化概述

1. 性能优化起因

比如我们在网站上订票我们肯定会会选择订票速度快的，如果一个网站长时间没有反馈，我们会选择离开。

2. 性能优化的影响

- 留存用户

- 可以提高网站的转化率

- 提高体验节约传播节约流量

3. RAIL模型

- 响应 Response:100ms反馈哟用户

- 动画 Animation:每一帧应该以 16ms 进行渲染

- 空闲 Idle:使用js主线程的时候，应该把任务划分到执行时间小于 50ms 的片段中去，这样可以释放线程以进行用户交互。

- 加载 Load:应该在小于 1s 的时间内加载完成你的网站，并可以进行用户交互。

#### 性能指标

1. FCP首次绘制dom

| FCP | 颜色 | 分数 |
| ---- | ---- | ---- |
| 0s-2s | 绿色 |快速|
| 2s-4s | 橙色 |中等|
| >4s | 红色 |慢|

2. LCP首次绘制最大内容元素的呈现

| LCP | 颜色 | 分数 |
| ---- | ---- | ---- |
| 0s-2.5s | 绿色 |快速|
| 2.5s-4s | 橙色 |中等|
| >4s | 红色 |慢|

3. FID首次输入延迟

| FID | 颜色 | 分数 |
| ---- | ---- | ---- |
| 0ms-100ms | 绿色 |快速|
| 100ms-300ms | 橙色 |中等|
| >300ms | 红色 |慢|

4. TTI完全达到可交互状态

| TTI | 颜色 | 分数 |
| ---- | ---- | ---- |
| 0s-3.8s | 绿色 |快速|
| 3.9s-7.3s | 橙色 |中等|
| >7.3s | 红色 |慢|

5. TBT是FCP与TTI时间

| TBT | 颜色 | 分数 |
| ---- | ---- | ---- |
| 0ms-300ms | 绿色 |快速|
| 300ms-600ms | 橙色 |中等|
| >600ms | 红色 |慢|

6. CLS测量整个生命周期发生意外的布局移动位置分数的总和

| CLS | 颜色 | 分数 |
| ---- | ---- | ---- |
| 0ms-100ms | 绿色 |快速|
| 100ms-250ms | 橙色 |中等|
| >250ms | 红色 |慢|

7. Speed Index 速度指数，可视区域填充指标

| Speed Index | 颜色 | 分数 |
| ---- | ---- | ---- |
| 0s-4.3s | 绿色 |快速|
| 4.4s-5.8s | 橙色 |中等|
| >5.8s | 红色 |慢|

8. web vitals(适用这套标准便可以衡量网站性能)

加载性能(LCP)

交互性(FID)

视觉稳定性（CLS）

9. 其他性能指标（使用window.performance获取）
(1) PerformanceTiming.navigationStart
PerformanceTiming.navigationStart 表示同一个浏览器上下文中，上一个文档卸载结束的 UNIX 时间戳。如果没有上一个文档，这个值与 PerformanceTiming.fetchStart 相同。
(2) PerformanceTiming.unloadEventStart
PerformanceTiming.unloadEventStart 表示 unload 事件抛出时的 UNIX 时间戳。如果没有上一个文档，或者重定向中的一个与当前文档不同源，该值为 0。
(3) PerformanceTiming.unloadEventEnd
PerformanceTiming.unloadEventEnd 表示 unload 事件处理完成时的 UNIX 时间戳。如果没有上一个文档，或者重定向中的一个与当前文档不同源，该值为 0。
(4) PerformanceTiming.redirectStart
PerformanceTiming.redirectStart 表示第一个 HTTP 重定向开始时的 UNIX 时间戳。如果没有重定向，或者重定向中的一个不同源，该值为 0。
(5) PerformanceTiming.redirectEnd
PerformanceTiming.redirectEnd 表示最后一个 HTTP 重定向完成时（即最后一个 HTTP 响应的最后一个比特被接收到的时间）的 UNIT 时间戳。如果额米有重定向，或者重定向中的一个不同源，该值为 0。
(6) PerformanceTiming.fetchStart
PerformanceTiming.fetchStart 表示浏览器准备好用 HTTP 请求来获取文档的 UNIX 时间戳。这个时间早于检查应用缓存。
(7) PerformanceTiming.domainLookupStart
PerformanceTiming.domainLookupStart 表示域名查询开始的 UNIX 时间戳。如果使用了持续连接，或者这个信息被存储到了缓存或本地资源，那么该值与 PerformanceTiming.fetchStart 相同。
(8) PerformanceTiming.domainLookupEnd
PerformanceTiming.domainLookupEnd 表示域名查询结束的 UNIX 时间戳。如果使用了持续连接，或者这个信息被存储到了缓存或本地资源，那么该值与 PerformanceTiming.fetchStart 相同。
(9) PerformanceTiming.connectStart
PerformanceTiming.connectStart 表示 HTTP 请求开始向服务器发送时的 UNIX 时间戳。如果使用持久连接，则该值与 PerformanceTiming.fetchStart 相同。
(10) PerformanceTiming.connectEnd
PerformanceTiming.connectEnd 表示浏览器与服务器之间的连接建立（即握手与认证等过程全部结束）的 UNIX 时间戳。如果使用持久连接，则该值与 PerformanceTiming.fetchStart 相同。
(11) PerformanceTiming.secureConnectionStart
PerformanceTiming.secureConnectionStart 表示浏览器与服务器开始安全链接的握手时的 UNIX 时间戳。如果当前网页不要求安全链接，该值为 0。
(12) PerformanceTiming.requestStart
PerformanceTiming.requestStart 表示浏览器向服务器发送 HTTP 请求时的 UNIX 时间戳。
(13) PerformanceTiming.responseStart
PerformanceTiming.responseStart 表示浏览器从服务器收到（或从本地缓存读取）第一个字节时的 UNIX 时间戳。如果传输层从开始请求后失败并连接被重开，该值会被重置为新的请求的相应的时间。
(14) PerformanceTiming.responseEnd
PerformanceTiming.responseEnd 表示浏览器从服务器收到（或从本地缓存读取，或从本地资源读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭的时间）的 UNIX 时间戳。
(15) PerformanceTiming.domLoading
Performance.domLoading 表示当前网页 DOM 结构开始解析时（即 Document.readyState 属性变为 loading，相应的 readystatechange 事件触发时）的 UNIX 时间戳。
(16) PerformanceTiming.domInteractive
Performance.domInteractive 表示当前网页 DOM 结构解析结束，开始加载内嵌资源时（即 Document.readyState 的属性为 interactive，相应的 readystatechange 事件触发时）的 UNIX 时间戳。
(17) PerformanceTiming.domContentLoadedEventStart
PerformanceTiming.domContentLoadedEventStart 表示解析器触发 DomContentLoaded 事件，即所有需要被执行的脚本已经被解析时的 UNIX 时间戳。
(18) PerformanceTiming.domContentLoadedEventEnd
PerformanceTiming.domContentLoadedEventEnd 表示所有需要被执行的脚本均已被执行完成时的 UNIX 时间戳。
(19) PerformanceTiming.domComplete
PerformanceTiming.domComplete 表示文档解析完成，即 Document.readyState 变为 complete 且相应的 readystatechange 事件被触发时的 UNIX 时间戳。
(20) PerformanceTiming.loadEventStart
PerformanceTiming.loadEventStart 表示该文档下，load 事件被触发的 UNIX 时间戳。如果还未发送，值为 0。
(21) PerformanceTiming.loadEventEnd
PerformanceTiming.loadEventEnd 表示该文档下，load 事件结束，即加载事件完成时的 UNIX 时间戳，如果事件未触发或未完成，值为 0。

- 重定向次数：performance.navigation.redirectCount

- 重定向耗时: redirectEnd - redirectStart

- DNS 解析耗时: domainLookupEnd - domainLookupStart

- TCP 连接耗时: connectEnd - connectStart

- SSL 安全连接耗时: connectEnd - secureConnectionStart

- 网络请求耗时 (TTFB): responseStart - requestStart

- 数据传输耗时: responseEnd - responseStart

- DOM 解析耗时: domInteractive - responseEnd

- 资源加载耗时: loadEventStart - domContentLoadedEventEnd

- 首包时间: responseStart - domainLookupStart

- 白屏时间: responseEnd - fetchStart

- 首次可交互时间: domInteractive - fetchStart

- DOM Ready 时间: domContentLoadEventEnd - fetchStart

- 页面完全加载时间: loadEventStart - fetchStart

- http 头部大小： transferSize - encodedBodySize

#### 性能测试

1. 使用Lighthouse

- 性能指标

- 生成报告

- 优化建议

2. 使用WebPageTest

- 需要安装可以用docker

3. 使用Chrome DevTools

- performance

- network

- memory

- 相关文档：https://docs.microsoft.com/zh-cn/microsoft-edge/devtools-guide-chromium/evaluate-performance/

#### url请求一个页面的生命周期


1. 从浏览器地址栏输入url后发生了什么？

url组成：

- protocol 协议头
- Host 主机域名或ip
- Port 端口号
- Path 目录路径
- Query 查询参数
- Fragment 片段

进程与线程：

进程就是一个程序运行的实例，操作系统会为进程创建独立的内存，用来存放运行所需的代码和数据；而线程是进程的组成部分，每个进程至少有一个主线程及可能的若干子线程，这些线程由所属的进程进行启动和管理。由于多个线程可以共享操作系统为其所属的同一个进程所分配的资源，所以多线程的并行处理能有效提高程序的运行效率。

多进程浏览器：

- 浏览器主进程：负责菜单栏、标题、文件访问、前进后退以及子进程管理。

- GPU进程：图形绘制

- 插件进程：采用沙箱模式，不能读取敏感数据

- 网络进程：负责网络资源加载

- 渲染进程：为每个标签页窗口开辟一个独立的进程，负责html,css转换为可交互的页面，其中包含多个子线程即js引擎线程、GUI渲染线程、事件触发线程、定时出发线程、异步http线程等，出于安全也放入了沙箱。

开启网络请求线程

2. 建立http请求

- DNS 解析：将域名转换为真实的ip地址，首先查询浏览器缓存，如果查询到ip就结束否则就会搜索系统自身DNS缓存，如果没有找到就会在host文件中查找
  如果还是找不到本地服务器就会迭代根域名服务器、com顶级服务器等最终返回目标服务器ip否则会报错。

- TCP链接：三次握手四次挥手

3. 前后端交互

- 请求反向代理服务器

- 后端处理流程：1.首先会有一层统一的验证环节，如跨域验证、安全校验拦截等。如果发现是不符合规则的请求，则直接返回相应的拒绝报文。
  2.首先会有一层统一的验证环节，如跨域验证、安全校验拦截等。如果发现是不符合规则的请求，则直接返回相应的拒绝报文。
- 浏览器缓存:在基于 HTTP 的前后端交互过程中，使用缓存可以使性能得到显著提升。具体的缓存策略分为两种：强缓存和协商缓存。
  强缓存就是当浏览器判断出本地缓存未过期时，直接读取本地缓存，无须发起 HTTP 请求，此时状态为：200 from cache.http1.1通过cache-control字段
  max-age属性规定过期时长比之前的expires更加准确。协商缓存需要浏览器发送请求判断是否需要缓存若未修改则从缓存中读取状态码为304
  具体判断流程通过if-none-match与服务器e-tag匹配判断数据是否发生变化，这样更加准确。

4. 关键渲染路径

- 构建对象模型：首先浏览器会通过解析 HTML 和 CSS 文件，来构建 DOM（文档对象模型）和 CSSOM（层叠样式表对象模型），绘制。

#### 加载优化

1. 图像懒加载

懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。
使用图片懒加载就可以解决上述问题。在滚动屏幕之前，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载。懒加载适用于图片较多，页面较长的页面场景中。

2. 懒加载的好处

- 减少无用资源的加载
- 提升用户体验
- 防止加载过多图片而影响其他资源文件的加载

3. 视频加载

图片和视频这类静态资源资源占比都比较大。与图片一样，视频同样可以延迟加载，来达到优化性能的目的。正常情况下加载视频，使用的是<video>标签，那么对于一些需要由用户自己播放的视频，最好指定<video>标签的preload属性为none，这样浏览器就不会预加载任何视频数据。为了占用空间，可以使用poster属性为<video>占位。实现如下：

```
<video controls preload="none" poster="replace.jpg">
  <source src="main.webm" type="video/webm">
  <source src="main.mp4" type="video/mp4">
</video>
```
4. 不需要自动播放

5. 视频代替gif动画

在业务开发中，我们应尽量使用视频代替尺寸过大的GIF动画，虽然GIF动画应用范围很广， 但是其在输出文件大小、图像色彩质量等方面均不如视频。GIF动画相对于视频具有三个附加的特性：没有音轨、连续循环播放、加载完自动播放，替换成视频后类似于：

```
<video controls autoplay loop muted playsinline>  
  <source src="main.webm" type="video/webm">
  <source src="main.mp4" type="video/mp4">
</video>
```
6. 首屏加载

骨架屏就是指在未加载完时，先简单的用图形勾勒出页面的大概布局，给用户一个视觉上更好一点的体验，等页面加载完成之后，再将骨架屏替换掉即可，如下图所示：

7. 资源优先级

在浏览器发起网络请求时，并非每个字节都具有相同的优先级，所以，浏览器通常会对所要加载的内容进行推测，将相对重要的信息先呈现给用户。比如浏览器一般会先加载CSS，再去加载JavaScript脚本和图像文件。当然，浏览器的判断并不一定都是准确的，下面就来看看如何影响浏览器对资源加载的优先级。
浏览器是基于自身的启发式算法，会对资源的重要性进行判断，来划分优先级，通常从低到高分为Lowest、Low、High、Highest等。比如在head标签中，CSS文件通常具有最高的优先级Hightest，其次是script标签所请求的脚本文件，当script带有defer或async的异步属性时，其优先级就会降低到Low。可以通过浏览器控制台查看资源的优先级（priority优先级选项默认不显示，可以在开发者工具网络面板中右键点击列标题来启用优先级列）：

8. 预加载

预加载使用<link ref="preload">来告诉浏览器当前指定的资源应该具有更高的优先级，需要尽快开始加载资源：
```js
<link ref="preload" as="script" href="xxx.js">
```
这里我们给link标签指定了一个as属性，它会告诉浏览器所要加载的资源的类型，当前需要加载的资源必须是这个指定类型的资源，不然不会进行预加载。
需要注意的是，<link ref="preload">是浏览器的强制性指令，preload后浏览器就必定去预加载相应的资源。使用时需要仔细测试，确保不会因为使用它而意外导致资源加载2次。
字体资源的预加载，为了减少用户等待站点文本内容的时间，以及避免闪烁，可以在HTML中使用<link rel ="preload">让浏览器知道样式文件中需要加载的字体资源：
```js
<link ref="preload" as="font" crossorign="crossorign" type="font/woff2" href="font.woff2">
```
这里的crossorign属性很重要，如果缺失，浏览器将忽略预加载的字体，并发起一个新的请求。因为浏览器使用匿名请求加载字体，只有使用crossorigin属性可以使预加载请求匿名。

9. 预链接

在网络较慢情况下下建立网络连接是非常耗时的。其原因主要是整个过程涉及到了DNS解析、重定向、三次握手过程等。如果能提前完后才能上述操作，那么就能带来更好的用户体验，与此同时，由于建立连接的大部分时间是消耗在等待的时间上，这时我们就可以使用预连接：
```js
<link ref="preconnect" href="https://xxx.cn/">
```
这里通过<link ref="preconnect">指令，告诉浏览器当前页面将与站点之间建立连接，希望尽快启动该过程。虽然这么做成本很低，但是会消耗抱回的CPU的时间，特别是在简历HTTPS安全连接时，如果建立好连接的10s之内没有使用该连接，浏览器就会关闭该连接，那么之前所有准备的资源就都浪费了。
除此之外，还有一种和预连接相关的类型<link ref="dns-prefetch">，也就是DNS预解析，它仅用来处理DNS查询。该属性在浏览器的支持度很高，并且可以明显缩短DNS的查询时间，所以被普遍使用。
流媒体资源的预连接就是一个很好的例子，对于不同来源的流媒体，我们希望在连接阶段节省一些时间但不一定立即开始获取内容。根据页面处理流内容的方式，可能需要等到脚本加载完毕并做好准备后才处理流。一旦准备加载资源，预连接可帮助我们缩短单次往返的等待时间。

10. 预提取

预提取则是利用机会让某些非关键资源提前获取。
预提取就是根据用户已发生的行为来判断接下来的预期行为，告诉浏览器稍后可能需要的资源，也就是当页面加载完成之后，且在宽带可用的情况下，这些资源将以lowest的优先级进行提取。
预提取最适合的场景就是为用户下一步可能的操作做好必要的准备，比如在搜索框搜索内容时，可以预提取结果列表中首个内容的详情页，或者在使用搜索查询是，预提取搜索结果下一页的内容。

#### 渲染优化

1. 渲染过程

渲染过程的5步：js处理=>计算样式=>页面布局=>绘制=>合成

1. 处理html标记并构建dom树
2. 处理css标记并构建cssom树
3. dom树与cssom树合成render树
4. 根据render树计算布局，与几何信息
5. 将各个节点绘制到屏幕上

2. html文件优化

除空格换行字符尽量保持精简去掉无用的注释，缩小尺寸（minify）压缩资源（gzip）使用http缓存（http cache）

3. css文件优化

除空格换行字符尽量保持精简去掉无用的注释，缩小尺寸（minify）压缩资源（gzip）使用http缓存（http cache）

- 将脚本放在页面head最前面

- 声明阻塞式渲染

- 声明打印网页时应用

- 声明媒体查询时应用

- 避免css文件中使用@import

4. js文件优化

- 除空格换行字符尽量保持精简去掉无用的注释，缩小尺寸（minify）压缩资源（gzip）使用http缓存（http cache）

- 将脚本放在页面末尾

- 使用异步延迟加载

5. 布局优化

触发浏览器布局与重绘的操作：1.DOM 元素几何属性的修改，这些属性包括
width,height,padding，margin,left,top 2.更改dom树结构 3. 获取特定的属性值操作offsetHeight,offsetWidth
,offsetTop,offsetLeft,scrollTop,scrollWidth等

- 避免对样式频繁修改

- 使用类对样式逐条修改

- 缓存对敏感样式属性值的计算

- 使用requestAnimationFrame方法控制渲染帧

- 降低绘制复杂度

6. 样式计算优化

- 降低选择器复杂度（css引擎是从右到做寻找）

- 尽量不使用通配符*

- 使用BEM规范

建议所有的元素都被单一的类修饰，BEM 是一种 CSS 的书写规范，它的名称是由三个单词的首字母组成的，分别是块（Block）、元素（Element）和修饰符（Modifier）。理论上它希望每行 CSS 代码只有一个选择器，这就是为了降低选择器的复杂性，对选择器的命名要求通过以下三个符号的组合来实现。

中画线（-）：仅作为连字符使用，表示某个块或子元素的多个单词之间的连接符。
单下画线（_）：作为描述一个块或其子元素的一种状态。
双下画线（__）：作为连接块与块的子元素。s

7. js执行优化

- 动画实现

- 合理使用防抖节流

- 使用web worker

8. 合成处理

- 在降低绘制复杂度小节中讲到，可通过将固定区域和动画区域拆分到不同图层上进行绘制，来达到绘制区域最小化的目的。接下来我们就来探讨如何创建新的图层，最佳方式便是使用 CSS 属性 will-change

- 通过opacity与transform生成新的图层，可以是元素单独绘制。

#### 代码优化

1. 数据存储方面

- 较少变量或函数在作用域链中的查找，因为作用域链越深被引擎搜索到的时间就越长。

- 对局部变量的缓存，比如多次获取一个dom我们可以缓存对当前dom的获取。

- 谨慎使用闭包，使用闭包可能导致内存泄漏，如果不能正确释放闭包资源会导致资源泄露。

2. 流程控制

- 条件判断如果出现if else语句可以尝试使用switch case代替代码更便于理解。

- if else 可以根据判断的优先级进行优化，把理论上出现频率较高的代码放在前面，或者用二分法实现可以减少匹配次数。

- 可以将条件值存储到数组或者对象中通过匹配key的值来获取当前条件的value,相当于策略模式。

- 通常如果离散值高于十个使用使用对象，两个至十个使用switch case,一两个使用if else。

- for循环语句使用时将判断条件写在外部缓存。

- for in 循环智能循环可枚举的属性，并且不可以手动结束循环这样很浪费性能forEach也不可以结束循环，推荐使用for of 可以遍历可迭代的数据结构性能方面好于前两者。

- 尽量不使用递归。

- 避免重复工作可以将结果缓存例如实现一个计算器我们可以缓存计算过的数字与结果。

3. 字符串

- 使用正则匹配时少用贪婪模式：多用贪婪模式会引起回溯问题，可以使用独占模式来避免回溯。

- 尽量使正则提前结束。

- 减少分支数量。

4. 快速响应

- 合理地加入异步队列把一些，推迟加载非首要资源。

5. 细节方面

- 合理地使用位运算代替数学计算，位运算可以提高大规模的运算速度。

- 使用原生方法，引擎使用原生方法加载更快，借助v8引擎加速，其中如果我们反复修改变量类型会导致v8的逆优化这点需要注意。

# 图片优化

## 彩色深度

- 8位色，每个像素所能显示的彩色数为2的8次方，即256种颜色。
- 16位增强色，16位彩色，每个像素所能显示的彩色数为2的16次方，即65536种颜色。
- 24位真彩色，每个像素所能显示的彩色数为24位，即2的24次方，约1678万种颜色。
- 32位真彩色，即在24位真彩色图像的基础上再增加一个表示图像透明度信息的Alpha通道。
- 32位真彩色并非是2的32次方的色数，它其实也是约1678万多色，不过它增加了256阶颜色的灰度,为了方便称呼，就规定它为32位色。

## 图像分类

- 光栅图：是基于 pixel像素构成的图像。JPEG、PNG，webp等都属于此类。
- 矢量图：使用点，线和多边形等几何形状来构图，具有高分辨率和缩放功能. SVG就是一种矢量图。


## 诞生历史

- GIF - 1987
- Base64- 1987
- JPEG - 1992
- PNG - 1996
- SVG - 1999
- JPEG2000 - 1997 to 2000
- APNG - 2004
- WebP - 2010
- ico - ?

## JPG/JPEG

平常我们大部分见到的静态图基本都是这种图片格式。这种格式的图片能比较好表现各种色彩，主要在压缩的时候会有所失真，也正因为如此，造就了这种图片格式体积的轻量。

## GIF

8位色，支持动画，支持背景透明，兼容性贼好。一般用于logo、icon、线框、动画

## JPEG 2000（了解）

JPEG2000的压缩比更高，而且不会产生原先的基于离散余弦变换的JPEG标准产生的块状模糊瑕疵。JPEG2000同时支持有损压缩和无损压缩。兼容性不好

## ICO

微软为windows桌面图标设计的，一个 ICO 文件可以包含多个图标。

## PNG
PNG格式是有三种版本的，分别为PNG-8，PNG-24，PNG-32，所有这些版本都不支持动画的。PNG-8跟GIF类似的属性是相似的，都是索引色模式，而且都支持背景透明。相对比GIF格式好的特点在与背景透明时，图像边缘没有什么噪点，颜色表现更优秀。PNG-24其实就是无损压缩的JPEG。而PNG-32就是在PNG-24的基础上，增加了透明度的支持。如果没有动画需求推荐使用png-8来替代gif，文件大，gif和jpg有渐进，png有交错，都是在没有完全下载图片的时候，能看到图片全貌。

## APNG：Animated PNG
APNG（Animated Portable Network Graphics）顾名思义是基于 PNG 格式扩展的一种动画格式，增加了对动画图像的支持，同时加入了 24 位图像和 8 位 Alpha 透明度的支持，这意味着动画将拥有更好的质量，其诞生的目的是为了替代老旧的 GIF 格式，但它目前并没有获得 PNG 组织官方的认可。目前除了ie几乎全部支持了

## webP
有损 WebP 图像平均比视觉上类似压缩级别的 JPEG 图像小25-35% 。无损耗的 WebP 图像通常比 PNG 格式的相同图像小26% 。WebP 还支持动画: 在有损的 WebP 文件中，图像数据由 VP8位流表示，该位流可能包含多个帧。
包括体积小、色彩表现足够、支持动画。但是兼容性方面，因为浏览器对 WebP 支持并不普遍。特别是移动端 IOS 系统基本不支持。

## SVG
SVG 是一种基于 xml 的矢量图形格式，它将图像的内容指定为一组绘图命令，这些命令创建形状、线条、应用颜色、过滤器等等。SVG 文件是理想的图表，图标和其他图像，可以准确地绘制在任何大小。因此，SVG 是现代 Web 设计中用户界面元素的流行选择。

## base64
图片的 base64 编码就是可以将一副图片数据编码成一串字符串，使用该字符串代替图像地址，图片随着 HTML 的下载同时下载到本地，不再单独消耗一个http来请求图片。


#### 图片优化

1. 图片压缩

- 无损压缩。压缩算法对图片的所有的数据进行编码压缩，能在保证图片的质量的同时降低图片的尺寸。png是其中的代表。
- 有损压缩。压缩算法不会对图片所有的数据进行编码压缩，而是在压缩的时候，去除了人眼无法识别的图片细节。因此有损压缩可以在同等图片质量的情况下大幅降低图片的尺寸。其中的代表是jpg

2. 工具压缩

- tinypng 免费、批量、速度块
- squoosh 在线图片压缩工具
- compressor 支持 JPG、PNG、SVG、GIF

3. webpack 压缩

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
        use: [
          {
            loader: 'file-loader',
            options: {
              name: '[name].[hash:7].[ext]'
            },
          },
          {
            loader: 'image-webpack-loader',
            options: {
              mozjpeg: {
                progressive: true,
                quality: 50,
              },
              optipng: {
                enabled: true,
              },
              pngquant: {
                quality: [0.5, 0.65],
                speed: 4,
              },
              gifsicle: {
                interlaced: false,
              },
              webp: {
                quality: 75
              },
            },
          },
        ],
      },
    ],
  },
}
```

4. 使用雪碧图

将多个图片合成一个图片减少请求次数，生成的图片体积会变大。webpack配置

```js

var path = require('path')
var SpritesmithPlugin = require('webpack-spritesmith')

module.exports = {
  plugins: [
    new SpritesmithPlugin({
      src: {
        cwd: path.resolve(__dirname, 'src/icon'),
        glob: '*.png'
      },
      target: {
        image: path.resolve(__dirname, 'src/spritesmith-generated/sprite.png'),
        css: path.resolve(__dirname, 'src/spritesmith-generated/sprite.css')
      },
      apiOptions: {
        cssImageRef: '~sprite.png'
      }
    })
  ]
}
```
通过上面配置就能将 src/icon 目录下的所有 png 文件合成雪碧图，并且输出到对应目录，同时还可以生成对应的样式文件，样式文件的语法会根据你配置的样式文件的后缀动态生成。

5. 使用字体图标

iconfont(字体图标)，即通过字体的方式展示图标，多用于渲染图标、简单图形、特殊字体等。阿里字体图标库。

6. 使用base64

有效的减少请求，base64会随着html一同下载到页面上，如果图片过大不建议使用会增大html页面的大小。
```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
        loader: 'url-loader',
        options: {
          limit: 10240,
          name: utils.assetsPath('img/[name].[hash:7].[ext]'),
        }
      },
    ],
  },
}
```


7. 使用 css 代替图片
比如实现修饰效果，如半透明、边框、圆角、阴影、渐变等，在当前主流浏览器中都可以用 CSS 达成，这样能减少图片的请求，达到优化的目的。


8. 使用 CDN 图片
CDN 的全称是 Content Delivery Network，即内容分发网络。CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。
CDN 节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；大部分请求在 CDN 边缘节点完成，CDN 起到了分流作用，减轻了源站的负载。


9. 图片懒加载

懒加载是一种网页性能优化的方式，它能极大提升用户体验。图片一直是影响网页性能的主要元凶，现在一张图片超过几兆已经是很经常的事了。如果每次进入页面就请求所有的图片资源，那么可能等图片加载出来用户也早就走了。所以进入页面的时候，只请求可视区域的图片资源。
```js
function lazyload() {
  let viewHeight = document.body.clientHeight //获取可视区高度
  let imgs = document.querySelectorAll('img[data-src]')
  imgs.forEach((item, index) => {
    if (item.dataset.src === '') return
    // 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置
    let rect = item.getBoundingClientRect()
    if (rect.bottom >= 0 && rect.top < viewHeight) {
      item.src = item.dataset.src
      item.removeAttribute('data-src')
    }
  })
}
// 可以使用节流优化一下
window.addEventListener('scroll', lazyload)
```
通过上面例子的实现，我们要实现懒加载都需要去监听 scroll 事件，尽管我们可以通过函数节流的方式来阻止高频率的执行函数,但是我们还是需要去计算 scrollTop,offsetHeight 等属性，通过IntersectionObserver
```js
const imgs = document.querySelectorAll('img[data-src]')
const config = {
  rootMargin: '0px',
  threshold: 0
}
let observer = new IntersectionObserver((entries, self) => {
  entries.forEach((entry) => {
    if (entry.isIntersecting) {
      let img = entry.target
      let src = img.dataset.src
      if (src) {
        img.src = src
        img.removeAttribute('data-src')
      }
      // 解除观察
      self.unobserve(entry.target)
    }
  })
}, config)

imgs.forEach((image) => {
  observer.observe(image)
})
```
10. 图片预加载
图片预加载，是指在一些需要展示大量图片的网站，将图片提前加载到本地缓存中，从而提升用户体验。

一种是隐藏在 css 的 background 的 url 属性里面.
```
#preload-01 {
  background: url(http://xxxx/image-01.png) no-repeat -9999px -9999px;
}
#preload-02 {
  background: url(http://xxxx/image-02.png) no-repeat -9999px -9999px;
}
#preload-03 {
  background: url(http://xxxx/image-03.png) no-repeat -9999px -9999px;
}


```
通过 CSS 的 background 属性将图片预加载到屏幕外的背景上。当它们在 web 页面的其他地方被调用时，浏览器就会在渲染过程中使用预加载（缓存）的图片。该方法虽然高效，但仍有改进余地。使用该法加载的图片会同页面的其他内容一起加载，增加了页面的整体加载时间。为了解决这个问题，我们增加了一些 JavaScript 代码，来推迟预加载的时间，直到页面加载完毕。
```js
function preloader() {
  if (document.getElementById) {
    document.getElementById('preload-01').style.background =
      'url(http://xxxx/image-01.png) no-repeat -9999px -9999px'
    document.getElementById('preload-02').style.background =
      'url(http://xxxx/image-02.png) no-repeat -9999px -9999px'
    document.getElementById('preload-03').style.background =
      'url(http://xxxx/image-03.png) no-repeat -9999px -9999px'
  }
}
function addLoadEvent(func) {
  var oldonload = window.onload
  if (typeof window.onload != 'function') {
    window.onload = func
  } else {
    window.onload = function () {
      if (oldonload) {
        oldonload()
      }
      func()
    }
  }
}
addLoadEvent(preloader)
```

javascript 的 Image 对象设置实例对象的 src 属性实现图片的预加载。

```js
function preloader() {
  if (document.images) {
    var img1 = new Image()
    var img2 = new Image()
    var img3 = new Image()
    img1.src = 'http://xxxx/path/to/image-001.gif'
    img2.src = 'http://xxxx/path/to/image-002.gif'
    img3.src = 'http://xxxx/path/to/image-003.gif'
  }
}
function addLoadEvent(func) {
  var oldonload = window.onload
  if (typeof window.onload != 'function') {
    window.onload = func
  } else {
    window.onload = function () {
      if (oldonload) {
        oldonload()
      }
      func()
    }
  }
}
addLoadEvent(preloader)
```
11. 响应式图片加载

什么是响应式图片加载？其实就是在不同分辨率的设备上显示不同尺寸的图片，避免资源的浪费。常用的方法就是 css3 的媒体查询(media query)。

```
@media  screen and (min-width: 1200px) {
  img {
    background-image: url('1.png');
  }
}
@media  screen and (min-width: 992px) {
  img {
    background-image: url('2.png');
  }
}
@media  screen and (min-width: 768px) {
  img {
    background-image: url('3.png');
  }
}
@media screen and (min-width: 480px) {
  img {
    background-image: url('4.png');
  }
}
```

HTML5 的picture 标签。放置多个 source 标签，以指定不同的图像文件名，进而根据不同的条件进行加载。添加一个回退的元素,现在很多浏览器对于 picture 这个标签还不支持
```
<picture>
  <source srcset="src/img/l.png" media="(min-width: 1200px)" />
  <source srcset="src/img/2.png" media="(min-width: 992px)" />
  <source srcset="src/img/4.png" media="(min-width: 768px)" />
  <img src="src/img/4.png" />
</picture>
```


12. 渐进式图片

渐进式图片的意思是在高画质图像加载完之前会先显示低画质版本。低画质版本由于画质低、压缩率高，尺寸很小，加载很快。在两者之间我们也可以根据需要显示不同画质的版本。
渐进式图片可以让用户产生图片加载变快的印象。用户不再盯着一片空白区域等待图片加载，而能看到图像变得越来越清晰，这样对用户体验也是友好的。骨架屏技术也是类似的原理。

#### 缓存优化

1. 减少dns查找：

2. http1.1

### http短连接：

早期：每次进行一次http通信就要断开一次tcp连接，可以用connection:keep-alive告知浏览器不要关闭连接（不是根本解决的办法）。

### http长连接:

为了完善版本http/1.1,不用声明connection:keep-alive，默认就是长连接，到了客户端服务器一段时间不回复，就会自动断开连接
对于同一个域名同时可以建立6个连接。

### 管道机制

http/1.1还提供了管道机制，在一个TCP连接里面可以同时发送多个请求，不用等待上一个请求完事。

### Content-Length字段

用来区分回来的数据包属于哪一个请求，根据Content-Length。1.0版本中不需要这个字段因为浏览器发现服务器已经关闭，就确定了已经完成了。

### 分块传输编码

Content-Length字段前提是必须知道回应的数据长度，这意味着服务器要等待所有操作完成才能发送数据，显然这样操作效率不高，通过分块传输
流模式取代这种方法。Transfer-Encoding: chunked,每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。

### 长连接的缺点

虽然 HTTP 1.1 版允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为"队头堵塞"（Head-of-line blocking）。

为了避免这种问题，可以减少请求数量，同时多开持久链接。（将文件合并，多申请域名因为同一个域名最大连接为6）

3. http2

### 二进制协议

HTTP/1.1 版的头信息肯定是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。

### 多工

HTTP2复用tcp链接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，可以避免对头阻塞。可以双向通信。

### 数据流

因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。
HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID 一律为奇数，服务器发出的，ID 为偶数。
数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1 版取消数据流的唯一方法，就是关闭 TCP 连接。这就是说，HTTP/2 可以取消某一次请求，同时保证 TCP 连接还打开着，可以被其他请求使用。
客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。

### 头信息压缩

HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。
HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

### 服务器推送

HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。
常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析 HTML 源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。

## 压缩传输的数据资源

4. 使用Gzip

服务端根据服务端中Accept-Encoding: gzip, deflate,压缩格式如果不传浏览器默认会传，服务端根据相应的压缩算法压缩，浏览器便可以解压。

### http头数据压缩

HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

### 请求体压缩

- DEFLATE，是一种使用 Lempel-Ziv 压缩算法（LZ77）和哈夫曼编码的压缩格式。
- ZLIB，是一种使用 DEFLATE 的压缩格式，对应 HTTP 中的 Content-Encoding: deflate。
- GZIP，也是一种使用 DEFLATE 的压缩格式，对应 HTTP 中的 Content-Encoding: gzip。

5. http缓存

### no-cache 与 no-store

no-cache 禁止任何缓存

no-store 允许缓存

### private 与 public

Cache-Control设置为private只允许浏览器缓存，public允许浏览器与代理服务器缓存。

### max-age和s-maxage

Cache-Control设置为max-age代表浏览器缓存最大时间，s-maxage代理服务器缓存的最大时间。

### 强缓存

对于强制缓存而言，如果浏览器判断所请求的目标资源有效命中，则可直接从强制缓存中返回请求响应，无须与服务器进行任何通信。

### 协商缓存

协商缓存就是在使用本地缓存之前，需要向服务器端发起一次 GET 请求，与之协商当前浏览器保存的本地缓存是否已经过期。

### 资源的实用策略

html可以使用协商缓存，改动小的可以使用强缓存，css可以通过生成独一无二的名字并将缓存设置为1年，js可以不使用代理服务器缓存

- 拆分源码，分包加载。
- 预估缓存时效。
- 控制中间代理服务器。
- 避免网址冗余。
- 规划缓存层次。
- 根域名相同缓存是共享的域名不同缓存不共享。

6. server worker缓存

7. CDN缓存

8. Push缓存

#### 构建优化

直接看webpack就行了

#### vue优化

1. 运行时性能优化

- 引入生产环境的vue文件

- 使用单文件组件预编译模板

- 使用object.freeze()

- 扁平化store数据结构

- 避免持久化store写入数据的性能问题

- 避免持久化store存储的容量持续增长

- 优化无限列表性能：窗口化

- 组件懒加载骨架屏

- vue组件keep-alive

- promise请求

2. 加载性能优化

- 服务器渲染SSR/预渲染Prerender

- 组件懒加载

- js分包

- 预加载

- 路由懒加载

- 减少不必要的分包

- 按需加载组件

3. 代码级别优化

- 不要在模板里面写过多的表达式

- 循环调用子组件时添加key

- v-show，v-if的使用

- 尽量不要使用float布局

- 慎用deep watch

#### 网络传输优化

1. 提取公共资源，只请求一次
2. 减少cookie尺寸
3. 组件使用无cookie域，静态资源请求不带cookie
4. 服务端gzip
5. 资源打包压缩
6. dns-prefetch预加载
7. DNS缓存

#### 浏览器关键帧优化

FP 首次绘制(白屏时间)
FCP 首次内容绘制
LCP 最大内容绘制
DCL dom内容解析完成
L 页面load事件
触发顺序 FP=>FCP=>LCP,DCL和L一般都是DCL在前，极少部分页面是L在前面

1. 优化FP

- 网络速度

- html中js放置到最后

- 使用prefetch,pre-dnsfetch,preconnect等方式链接资源

- script使用defer,sync,不影响dom跟css的解析

2. 优化FCP

- 预加载

- 资源懒加载

3. 优化LCP

- loading图

4. 优化DCL

- 无需优化

5. 优化L

- 首页资源分割+懒加载

- 预解析+预链接

- http1.x==>http2.0

- 资源开启gzip压缩，js/css文件压缩

- 使用http缓存或者service worker














