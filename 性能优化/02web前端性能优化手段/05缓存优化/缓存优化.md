# 缓存优化

### 减少dns查找：

## http1.1

### http短连接：

早期：每次进行一次http通信就要断开一次tcp连接，可以用connection:keep-alive告知浏览器不要关闭连接（不是根本解决的办法）。

### http长连接:

为了完善版本http/1.1,不用声明connection:keep-alive，默认就是长连接，到了客户端服务器一段时间不回复，就会自动断开连接
对于同一个域名同时可以建立6个连接。

### 管道机制

http/1.1还提供了管道机制，在一个TCP连接里面可以同时发送多个请求，不用等待上一个请求完事。

### Content-Length字段

用来区分回来的数据包属于哪一个请求，根据Content-Length。1.0版本中不需要这个字段因为浏览器发现服务器已经关闭，就确定了已经完成了。

### 分块传输编码

Content-Length字段前提是必须知道回应的数据长度，这意味着服务器要等待所有操作完成才能发送数据，显然这样操作效率不高，通过分块传输
流模式取代这种方法。Transfer-Encoding: chunked,每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。

### 长连接的缺点

虽然 HTTP 1.1 版允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为"队头堵塞"（Head-of-line blocking）。

为了避免这种问题，可以减少请求数量，同时多开持久链接。（将文件合并，多申请域名因为同一个域名最大连接为6）

## http2

### 二进制协议

HTTP/1.1 版的头信息肯定是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。

### 多工

HTTP2复用tcp链接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，可以避免对头阻塞。可以双向通信。

### 数据流

因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。
HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID 一律为奇数，服务器发出的，ID 为偶数。
数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1 版取消数据流的唯一方法，就是关闭 TCP 连接。这就是说，HTTP/2 可以取消某一次请求，同时保证 TCP 连接还打开着，可以被其他请求使用。
客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。

### 头信息压缩

HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。
HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

### 服务器推送

HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。
常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析 HTML 源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。

## 压缩传输的数据资源

### 使用Gzip

服务端根据服务端中Accept-Encoding: gzip, deflate,压缩格式如果不传浏览器默认会传，服务端根据相应的压缩算法压缩，浏览器便可以解压。

### http头数据压缩

HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

### 请求体压缩

- DEFLATE，是一种使用 Lempel-Ziv 压缩算法（LZ77）和哈夫曼编码的压缩格式。
- ZLIB，是一种使用 DEFLATE 的压缩格式，对应 HTTP 中的 Content-Encoding: deflate。
- GZIP，也是一种使用 DEFLATE 的压缩格式，对应 HTTP 中的 Content-Encoding: gzip。

## http缓存

### no-cache 与 no-store

no-cache 禁止任何缓存

no-store 允许缓存

### private 与 public

Cache-Control设置为private只允许浏览器缓存，public允许浏览器与代理服务器缓存。

### max-age和s-maxage

Cache-Control设置为max-age代表浏览器缓存最大时间，s-maxage代理服务器缓存的最大时间。

### 强缓存

对于强制缓存而言，如果浏览器判断所请求的目标资源有效命中，则可直接从强制缓存中返回请求响应，无须与服务器进行任何通信。

### 协商缓存

协商缓存就是在使用本地缓存之前，需要向服务器端发起一次 GET 请求，与之协商当前浏览器保存的本地缓存是否已经过期。

### 资源的实用策略

html可以使用协商缓存，改动小的可以使用强缓存，css可以通过生成独一无二的名字并将缓存设置为1年，js可以不使用代理服务器缓存

- 拆分源码，分包加载。
- 预估缓存时效。
- 控制中间代理服务器。
- 避免网址冗余。
- 规划缓存层次。
- 根域名相同缓存是共享的域名不同缓存不共享。

## server worker缓存

## CDN缓存

## Push缓存

