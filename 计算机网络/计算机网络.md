## 计算机网络
### -------http请求头------
#### http有哪些常见的请求头和响应头
|  请求头                     | 描述                                     | 示例 |
|  ------------------------- | --------------------------------------- | ---- |
| Accept                     | 用户代理支持的MIME类型列表                  | Accept: text/html,application/xhtml+xml,application/xml;q=0.9 |
| Accept-Encoding            | 用户代理支持的压缩方法（优先级）              | Accept-Encoding: br, gzip, deflate |
| Accept-Language            | 用户代理期望的语言（优先级）                  | Accept-Language: zh-CN,zh;q=0.9 |
| Cache-Control              | 缓存机制                                  | Cache-Control: max-age=0 |
| Connection                 | 是否持久连接                               | Connection: keep-alive |
| Cookie                     | HTTP cookies                             | 服务器通过Set-Cookie存储到客户端的 Cookie |
| Host                       | 主机名 + 端口号                            | Host: 127.0.0.1:8080 |
| If-Match                   | 请求指定标识符资源                          | If-Match: "56a88df57772gt555gr5469a32ee75d65dcwq989" |
| If-Modified-Since          | 请求指定时间修改过的资源                     | If-Modified-Since: Wed, 19 Oct 2020 17:32:00 GMT |
| If-None-Match              | 请求非指定标识符资源                        | If-None-Match: "56a88df57772gt555gr5469a32ee75d65dcwq989" |
| Upgrade-Insecure-Requests  | 客户端优先接受加密和有身份验证的响应，支持CSP   | Upgrade-Insecure-Requests: 1 |
| User-Agent                 | 用户代理                                  | User-Agent:Safari/537.36 |
| Vary                       | 缓存策略，常用于自适应缓存配置和 SEO           | Vary: User-Agent |

|  响应头                     | 描述                                     | 示例 |
|  ------------------------- | --------------------------------------- | ---- |
| Allow                      | 服务器支持哪些请求方法                      | Allow: POST,GET,OPTIONS |
| Cache-Control              | 缓存机制                                 | Cache-Control: public, max-age=3600 |
| Connection                 | 是否持久连接                              | Connection: keep-alive |
| Content-Encoding           | 内容编码方式                              | Content-Encoding: br |
| Content-Type               | 内容的MIME类型                            | Content-Type: text/html; charset=UTF-8 |
| Date                       | 报文创建时间                              | Date: Sun, 28 Feb 2021 11:52:51 GMT |
| Expires                    | 资源过期时间                              | Expires: Sun, 28 Feb 2021 12:52:51 GMT |
| ETag                       | 资源标识符                                | ETag: "56a88df57772gt555gr5469a32ee75d65dcwq989" |
| Set-Cookie                 | 服务端向客户端发送Cookie                   | Set-Cookie: token=6e204d9b-103a-431e-b8de-ba97b2d1; path=/; HttpOnly |
#### http的请求报文与响应报文的格式是什么
一个HTTP请求报文由请求行（request line） 、请求头部（header）、空行和请求数据4个部分组成。
#### 既然http是无状态协议，那他是如何保持登录状态的
通过 cookie 或者 Authorization header 来传递凭证，在服务端进行认证
#### 我们如何从http的报文中得知该服务使用的技术栈
一般有两个 response header，有时服务端为了隐蔽自己真实的技术栈会隐蔽这两个字段
X-Powerd-By
Server
#### 在发送http请求报文时，Host是必要的吗
是有必要的，因为我们不知道会途径会不会有代理出现， 如果直接到达服务器的话，服务器是可以通过路径知道资源在哪，但是如果通过代理的话，代理无法得知具体服务器是什么地址
#### http 响应头中如果 content-type 为 application/octet-stream，则代表什么意思
代表二进制流，一般用以下载文件
#### CSP 是干什么用的了
CSP 只允许加载指定的脚本及样式，最大限度地防止 XSS 攻击，是解决 XSS 的最优解。CSP 的设置根据加载页面时 http 的响应头 Content Security Policy 在服务器端控制。
外部脚本可以通过指定域名来限制：Content-Security-Policy: script-src 'self'，self 代表只加载当前域名
如果网站必须加载内联脚本 (inline script) ，则可以提供一个 nonce 才能执行脚本，攻击者则无法注入脚本进行攻击。Content-Security-Policy: script-src 'nonce-xxxxxxxxxxxxxxxxxx'
#### http 请求头中的 X-Forwarded-For 代表什么意思
X-Forwarded-For 被反向代理器生成，如 nginx，traefik 等，一般用作标识客户端真实的 IP 地址，目前已成为事实上的标准。
#### 什么情况下会发送 OPTIONS 请求
当一个请求跨域且不是简单请求时就会发送 OPTIONS 请求
满足以下条件就是一个简单请求:
Method: 请求的方法是 GET、POST 及 HEAD
Header: 请求头是 Content-Type、Accept-Language、Content-Language 等
Content-Type: 请求类型是 application/x-www-form-urlencoded、multipart/form-data 或 text/plain
而在项目中常见的 Content-Type: application/json 及 Authorization: <token> 为典型的非简单请求，在发送请求时往往会带上 Options
#### SameSite Cookie 有哪些值，是如何预防 CSRF 攻击的
None: 任何情况下都会向第三方网站请求发送 Cookie
Lax: 只有导航到第三方网站的 Get 链接会发送 Cookie，跨域的图片、iframe、form表单都不会发送 Cookie
Strict: 任何情况下都不会向第三方网站请求发送Cookie
目前，主流浏览器 Same-Site 的默认值为 Lax，而在以前是 None，将会预防大部分 CSRF 攻击，如果需要手动指定 Same-Site 为 None，需要指定 Cookie 属性 Secure，即在 https 下发送
#### 什么是点击劫持(ClickJacking)，如何预防
避免自己网站被当做 iframe 嵌入到非法网站引导用户点击
使用js控制或者
或者使用 CSP 的指令 frame-ancestors 进行预防
Content-Security-Policy: frame-ancestors 'none';
Content-Security-Policy: frame-ancestors 'self' https://www.example.org;
#### http 中 referer 请求头是做什么的
1. 防止恶意请求(只有referer限制的域名才能访问)
2. 防止CSRF攻击

### -------http状态码-------
#### http常见的状态码有哪些
1. 1XX 表示消息
2. 2XX 表示成功
3. 3XX 表示重定向
4. 4XX 表示客户端错误
5. 5XX 表示服务端错误
1. 200 最喜欢见到的状态码，表示请求成功
2. 301 永久重定向
3. 302 临时重定向
4. 304 自上次请求，未修改的文件
5. 400 错误的请求
6. 401 未被授权，需要身份验证，例如token信息等等
7. 403 请求被拒绝
8. 404 资源缺失，接口不存在，或请求的文件不存在等等
9. 500 服务器端的未知错误
10. 502 网关错误
11. 503 服务暂时无法使用
#### http状态码中301,302和307有什么区别
1. 301，Moved Permanently。永久重定向，该操作比较危险，需要谨慎操作：如果设置了301，但是一段时间后又想取消，但是浏览器中已经有了缓存，还是会重定向。
2. 302，Found。临时重定向，但是会在重定向的时候改变 method: 把 POST 改成 GET，于是有了 307
3. 307，Temporary Redirect。临时重定向，在重定向时不会改变 method
#### http状态码502与504有什么区别
1. 502 Bad Gateway。一般表现为你自己写的应用层服务(Java/Go/PHP)挂了，网关层无法接收到响应
2. 504 Gateway Timeout。一般表现为应用层服务 (upstream) 超时，如查库操作耗时十分钟，超过了 Nginx 配置的超时时间
#### http 状态码 204 使用在什么场景
对于HEAD和OPTIONS方法，可以使用204状态码表示请求已成功处理且没有响应主体内容。然而，对于打点请求，建议选择其他适合的状态码来表示请求结果，并根据需要返回相关数据
#### http 状态码 401 和 403 有什么区别
401 Unauthorized 请求的资源没有权限，需要认证。一般代表没有携带 token，或者 token 失效，而造成对该资源没有权限。需重新认证，传递正确的 token。
403 Forbidden 请求的资源禁止访问。一般代表用户所拥有的权限不满足该资源的权限。如学生去访问教师资源，学生 A 访问学生 B 的成绩单等数据资源。还有一种情况是爬虫爬取页面被监控到而返回 403。
#### 当服务器资源返回 304 时与那些 HTTP 响应头有关
304 Not Modified，表示资源没有发生过改变。 与协商缓存有关，也就是Last-Modify和Etag两个http响应头，在获取资源之前先判断缓存资源是否发生过改变。 no-cache表示使用缓存资源时，都向服务器请求验证。 no-store才表示不使用任何形式的缓存。
#### http 向 https 做重定向应该使用哪个状态码
般用作 301 的较为多，但是也有使用 302，如果开启了 HSTS 则会使用 307

### -------http请求-------
#### http方法 get 与 post 有何区别
GET在浏览器回退时是无害的，而POST会再次提交请求。
GET产生的URL地址可以被Bookmark，而POST不可以。
GET请求会被浏览器主动cache，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
GET请求在URL中传送的参数是有长度限制的，而POST么有。
对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
GET参数通过URL传递，POST放在Request body中。
GET产生一个TCP数据包；POST产生两个TCP数据包。
#### http几种请求方式
1） GET
传递参数长度受限制，因为传递的参数是直接表示在地址栏中，而特定浏览器和服务器对url的长度是有限制的。
因此，GET不适合用来传递私密数据，也不适合拿来传递大量数据。
一般的HTTP请求大多都是GET。
2）POST
POST把传递的数据封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，对数据量没有限制，也不会显示在URL中。
表单的提交用的是POST。
3）HEAD
HEAD跟GET相似，不过服务端接收到HEAD请求时只返回响应头，不发送响应内容。所以，如果只需要查看某个页面的状态时，用HEAD更高效，因为省去了传输页面内容的时间。
4）DELETE
删除某一个资源。
5）OPTIONS
用于获取当前URL所支持的方法。若请求成功，会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。
6）PUT
把一个资源存放在指定的位置上。
本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。
7）TRACE
回显服务器收到的请求，主要用于测试或诊断。
8）CONNECT
CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。

### -------http缓存-------
#### 简述http的缓存机制
1. 强缓存
   再次请求时无需再向服务器发送请求
2. 协商缓存
#### 简述你们前端项目中资源的缓存配置策略
html设置协商缓存
静态资源 hash + 强缓存
#### no-cache 与 no-store 的区别是什么
no-store 永远都不要在客户端存储资源，每次永远都要从原始服务器获取资源
no-cache 可以在客户端存储资源，但每次都必须去服务器做新鲜度校验，来决定从服务器获取最新资源 (200) 还是从客户端读取缓存 (304)，即所谓的协商缓存
#### http响应头中的Etag值是如何生成的
关于 etag 的生成需要满足几个条件，至少是宽松满足
当文件更改时，etag 值必须改变。
尽量便于计算，不会特别耗 CPU。这样子利用摘要算法生成 (MD5, SHA128, SHA256) 需要慎重考虑，因为他们是 CPU 密集型运算
必须横向扩展，分布式部署时多个服务器节点上生成的 etag 值保持一致。这样子 inode 就排除了
#### 如果http响应头中的Etag值改变了，是否意味着文件内容一定已经更改
不一定
#### http服务中静态文件的Last-Modified是根据什么生成的
一般会选文件的 mtime，表示文件内容的修改时间
针对静态资源而言，一般会选择文件的 mtime 元属性作为上次修改时间，该元属性表示文件内容的修改时间，在linux中可以用stat命令来查看文件属性，其中就包括了mtime和ctime。mtime指的是文件内容修改时间，而ctime指的是文件修改时间
#### http 响应头中的 Date 与 Last-Modified 有什么不同，网站部署时需要注意什么
LM-Factor 与它俩有关。
简而言之，一个静态资源没有设置 Cache-Control 时会以这两个响应头来设置强制缓存时间，而非直接进行协商缓存。在涉及到 CDN 时，表现更为明显，体现在更新代码部署后，界面没有更新。
#### HTTP 响应头 cache-control: s-maxAge=0 是什么意思
缓存立即失效
#### http 缓存控制中 Cache-Control 为 public 与 private 有何区别
private：只允许在客户端缓存，不允许在代理服务器上缓存 public：完全公开，客户端跟代理服务器都可以缓存
#### 现代前端应用应如何配置 HTTP 缓存机制
文件路径中带有 hash 值：一年的强缓存。因为该文件的内容发生变化时，会生成一个带有新的 hash 值的 URL。前端将会发起一个新的 URL 的请求。配置响应头 Cache-Control: public,max-age=31536000,immutable
文件路径中不带有 hash 值：协商缓存。大部分为 public 下文件。配置响应头 Cache-Control: no-cache 与 etag/last-modified
#### 在 nginx 中如何配置 HTTP 协商缓存
nginx后期已经默认开启协商缓存了
location /public {
add_header Cache-Control no-cache;
etag on;
if_modified_since exact;
}

### -------http代理-------
#### http proxy的原理
代理服务器会自动提取请求数据包中的HTTP请求数据发送给服务端，并服务端的HTTP响应数据转发给发送请求的客户端，HTTP代理服务器使用的端口通常是8080。
对于Web客户端来说，代理扮演的服务器角色，接收请求（Request），返回响应（Response）。
对于Web服务器来说，代理扮演的客户端角色，发送请求（Request），接收响应（Response）。
#### HTTP 代理步骤
客户端向代理发起TCP连接；
代理接收客户端的连接，双方建立连接；
客户端向代理发送HTTP请求，请求内容和没有HTTP代理的内容完全相同；
代理解析HTTP请求；
代理向服务器发起TCP连接；
服务器接收代理的连接；
代理向服务器发送HTTP请求（这个HTTP请求是基于用户的HTTP请求，可能会有修改）
服务器发送响应给代理；
代理发送响应给发送请求的客户端；

### -------http几个版本-------
#### 随着http2发展，前端优化哪些方案可以被替代
雪碧图
资源文件合并
#### http2与http1.1有什么改进
二进制分帧
请求多路复用 (Stream/Frame)
头部压缩: (HPack)
服务端推送: (PUSH_PROMISE)
#### http 1.1 中的 keep-alive 有什么作用
在 http 1.1 中，在响应头中设置 keep-alive 可以在一个 TCP 连接上发送多个 http 请求
避免了重开 TCP 连接的开销
避免了刷新时重新建立 SSL 连接的开销
避免了QPS过大时，服务器的连接数过大
#### http2 中 server push 与 websocket 有什么区别
HTTP2 Server Push，一般用以服务器根据解析 index.html 同时推送 JPG/JS/CSS 等资源，而免了服务器发送多次请求
websocket，用以服务器与客户端手动编写代码去推送进行数据通信
#### 简述 http3，http3 解决了什么问题
http3 基于 UDP 协议，这是与以前版本的 http 最大的不同，可以解决 http2 TCP 连接阻塞的问题。
#### http2 中 Stream 与 Frame 是什么关系
Stream 为 Request/Response 报文的双向通道，一个完整资源的请求与响应是一个 stream，特殊的 stream 作为 Settings、Window_Update 等 Frame 发送的通道
Frame 为 http2 通信的最小单位，有 Data、Headers 等，一个 Stream 包含多个 Frame，如一条 http 请求包含 Header、Data Frame 等
#### 当在浏览器中看到某资源使用了 http2 后，使用 curl 为什么看到的仍是 http 1.1
当前 curl 的版本及支持的协议以及功能特性没有支持 HTTP2
#### 什么是队首阻塞，如何解决，原理如何
队首阻塞包含http应用层协议上的队首阻塞和tcp传输层的队首阻塞
http应用层协议上的队首阻塞: 以http1.1为例，一个tcp连接一次只能处理一个请求，如果接受端处理慢的话，后面的请求就得排队，这是导致队首阻塞的根本原因 虽然http1.1提出了管线技术，支持同时发起多个请求出去，但是又限制了接收端返回必须得按照顺序，所以这项技术也未能解决队首阻塞。
http2.0 提出了 frame 和 stream的概念， 把请求数据分成了不同的二进制frame，有strameid标识，包装进不同的stream通过同一个tcp管道进行并发的多路复用传输， 接收端根据streamid来进行组装，解决了队首阻塞的问题。
但是依然没有解决tcp传输层的队首阻塞，如果过程中一个包丢了，需要重传，就需要后面的包等待了

### -------https-------
#### https 层可以做哪些性能优化

#### https 中证书的格式化信息有哪些
在 TLS 握手过程中，服务器端需要给客户端提供证书，X.509 就是证书的标准格式
序列号
Subject Name
Issuer Name
电子签名
签名算法
公钥
扩展
#### https连接时如何保证证书没被废弃掉
#### https中是如何进行身份认证的
电子签名
#### https是如何保证报文安全的
https主要解决三个安全问题：
内容隐私
防篡改
确认对方身份
https并不是直接通过非对称加密传输过程，而是有握手过程，握手过程主要是和服务器做通讯，生成私有秘钥，最后通过该秘钥对称加密传输数据。还有验证证书的正确性。 证书验证过程保证了对方是合法的，并且中间人无法通过伪造证书方式进行攻击。
#### https中如何保证证书是可信任的
数字签名
数字签名的原理其实很简单，就是把公钥私钥的用法反过来，之前是公钥加密、私钥解密，现在是私钥加密、公钥解密。但又因为非对称加密效率太低，所以私钥只加密原文的摘要，这样运算量就小的多，而且得到的数字签名也很小，方便保管和传输。
数字证书和CA
因为公钥是任何人都可以发布的，所以我们需要引入第三方来保证公钥的可信度，这个“第三方”就是我们常说的 CA（Certificate Authority，证书认证机构），CA 对公钥的签名认证也是有格式的，要包含公钥的序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“数字证书”（Certificate）。小一点的 CA 可以让大 CA 签名认证，但链条的最后，也就是 Root CA，就只能自己证明自己了，这个就叫“自签名证书”（Self-Signed Certificate）或者“根证书”（Root Certificate）。你必须相信，否则整个证书信任链就走不下去了。
#### 简述下TLS 握手过程
在 TLS 1.2 中，握手协议过程需要耗费两个 RTT，过程如下
[OUT] Client Hello，客户端选出自身支持的 TLS 版本号、cipher suites、Client Random、SessionId 传送给服务器端 (有可能可复用 Session)
[IN] Server Hello，服务器端选出双方都支持的 TLS 版本，cipher suite 、Server Random、SeesionId 给客户端
[IN] Certificate，服务器端给客户端发送证书，用以身份验证及提供公钥
[IN] Server Key Exchange，服务器端给客户端发送密钥交换算法的一些参数
[IN] Server Finished
[OUT] Client Key Exchange，客户端给服务器端发送密钥交换算法的一些参数，计算出预主密钥 (pre master secret)，使用密钥交换算法（一般是 ECDHE）传递给服务器端。双方根据（Client Random、Server Random、Pre Master Secret）三个随机数生成对称加密中的密钥（master secret）。（再根据 master secret 生成 Session Keys，包括 Client MAC Key、Client Write Key、Server MAC Key、Server Write Key。用以以后对的通信加密。）
[OUT] Change Cipher Spec，告知以后的消息开始对称加密通信
[OUT] Finished，加密消息并完整性验证，标志着握手阶段成功并结束（对握手消息使用 Client Write Key 加解密，并使用 Client MAC Key 进行完整性校验）
[IN] Change Cipher Spec，告知以后的消息开始对称加密通信。此时服务器端通过密钥交换算法拿到 pre master secret，并根据三个随机数生成 master secret。
[IN] Finished，加密消息并完整性验证，标志着握手阶段成功并结束
#### TLS1.3相比TLS1.2 有何不同
握手时间从以前的 2RTT 缩短到 1RTT，通过 Pre shared-key 减少了单独的 ServerKeyExchange 与 ClientKeyExchange 消耗的一个 RTT
0-RTT Resumption
#### 在TLS层如何优化网站性能
OSCP Stapling
TLS 1.3
#### 什么是Basic Auth和Digest Auth
Basic Auth：使用Base64编码的用户名和密码，将其放置在HTTP请求头中进行身份验证； Digest Auth：使用摘要（Digest）算法，将密码使用算法加密后放在HTTP请求头中进行身份验证； 这两种身份验证在实际应用中比较少，比较流行的还是Token-based Auth。 Token-based Auth：使用令牌（Token），客户端在登录成功后获取令牌，之后的请求中将令牌包含在请求头中进行身份验证。
#### DV、OV、EV 类的证书有何区别
1. Domain Validation，最低级别的证书校验，Lets Encrypt 就是这种，因此也不怎么需要花钱
2. Organization Validation，校验证书中组织身份，从中可以看出公司名称，所在地等信息
3. Extended Validation，最高级别的证书校验
#### 什么是 HSTS
HSTS 是 HTTP 严格传输安全（HTTP Strict Transport Security） 的缩写。 这是一种网站用来声明他们只能使用安全连接（HTTPS）访问的方法。 如果一个网站声明了 HSTS 策略，浏览器必须拒绝所有的 HTTP 连接并阻止用户接受不安全的 SSL 证书

### -------http压缩-------
#### gzip的原理是什么，如何配置
gzip 的核心是 Deflate，而它使用了 LZ77 算法与 Huffman 编码来压缩文件，重复度越高的文件可压缩的空间就越大。
因此 gzip 用于 HTTP 文件传输中，比如 JS、CSS 等，但一般不会压缩图片。在 HTTP Response 报文中，用 Content-Encoding 指明使用 gzip 压缩，
gzip 一般在反向代理那一层，如 nginx 进行处理
#### 可以对图片开启gzip压缩吗？为什么
不需要开启，如果开启的话，有可能使图片变的更大。如果你注意一些网站的 img 资源时，就会发现他们都没有开启 gzip
#### 如何确保你们的项目开启了 gzip
content-encoding: gzip

### -------cors-------
#### 关于 cors 的响应头有哪些
Access-Control-Allow-Origin
Access-Control-Allow-Methods
Access-Control-Allow-Headers
Access-Control-Allow-Credentials
Access-Control-Expose-Headers
Access-Control-Max-Age
#### CORS 如果需要指定多个域名怎么办
根据请求头中的 Origin 来设置响应头 Access-Control-Allow-Origin，思路如下
总是设置 Vary: Origin，避免 CDN 缓存破坏 CORS 配置
如果请求头不带有 Origin，证明未跨域，则不作任何处理
如果请求头带有 Origin，证明浏览器访问跨域，根据 Origin 设置相应的 Access-Control-Allow-Origin: <Origin>
#### 既然 cors 配置可以做跨域控制，那可以防止 CSRF 攻击吗
对 CORS 一点用也没有
form 提交不通过 CORS 检测，你可以在本地进行测试
即使通过 xhr 及 fetch 进行提交被 CORS 拦住，但是对于简单请求而言，请求仍被发送，已造成了攻击

### -------http其他-------
#### 如何避免 CDN 为 PC 端缓存移动端页面
使用 Vary: User-Agent，根据 UA 进行缓存。
Vary: User-Agent
但最好不要出现这种情况，PC 端和移动端如果是两套代码，建议用两个域名，理由如下
nginx 判断是否移动端容易出错
对缓存不友好
#### 我们上传图片为 Blob/File 对象时，是如何向服务器端传送数据的
new FormData()可以发送二进制对象 #https://developer.mozilla.org/zh-CN/docs/Web/API/FormData 也可以发送base64然后保存
#### 什么是 base64 与 URL Safe base64
base64 由 0-9、A-Z、a-z 及 +、/ 组成，但是在 URL 中使用 base64 时，/ 容易与路径符号发生冲突。
因此，URL Safe Base64 将 + 替换为 _，/ 替换为 -。
#### Data URL 的应用场景及如何生成
Data URLs 由四个部分组成：
data:[<mediatype>][;base64],<data>
1. 前缀(data:)
2. 指示数据类型的MIME类型
3. 如果二进制数据则为可选的base64标记，比如图片
4. 数据
#### HTTP 与 TCP 中的 keep-alive 各是什么
HTTP 的 Keep-Alive，是由应用层（用户态） 实现的，称为 HTTP 长连接；
TCP 的 Keepalive，是由 TCP 层（内核态） 实现的，称为 TCP 保活机制；
#### websocket 和短轮询有什么区别
短轮询是每隔一段时间发送一次HTTP请求，WebSocket 是全双工通讯的协议，允许服务端主动向客户端推送数据。短轮询的实时性不高，而且影响性能，而WebSocket做到了真正意义上的实时。

### -------TCP与UDP-------
#### 什么是TCP
TCP 是面向连接的、可靠的、基于字节流的传输层通信协议
1. 面向连接： 一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；
2. 可靠的： 无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；
3. 字节流： 用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。
#### 什么是 TCP 连接
用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。
建立一个链接需要客户端与服务端达成三个共识
1. socket:由ip地址与端口组成
2. 序列号：解决乱序问题
3. 窗口大小：流量控制
#### 如何唯一确定一个 TCP 连接呢
TCP四元组可以唯一的确认一个链接：源地址源端口，目标地址目标端口
#### UDP协议介绍
UDP 协议真的非常简，头部只有 8 个字节，
UDP头部格式非常简单：
1. 目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。
2. 包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。
3. 校验和：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包。
   TCP 和 UDP 区别：
#### UDP 和 TCP 有什么区别呢？分别的应用场景是
1. 连接
   TCP 是面向连接的传输层协议，传输数据前先要建立连接。
   UDP 是不需要连接，即刻传输数据。
2. 服务对象
   TCP 是一对一的两点服务，即一条连接只有两个端点。
   UDP 支持一对一、一对多、多对多的交互通信
3. 可靠性
   TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。
   UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：如何基于 UDP 协议实现可靠传输？(opens new window)
4. 拥塞控制、流量控制
   TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
   UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。
5. 首部开销
   TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。
   UDP 首部只有 8 个字节，并且是固定不变的，开销较小。
6. 传输方式
   TCP 是流式传输，没有边界，但保证顺序和可靠。
   UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。
7. 分片不同
   TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
   UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。
#### TCP 和 UDP 应用场景
由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：
FTP 文件传输；
HTTP / HTTPS；
由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：
包总量较少的通信，如 DNS 、SNMP 等；
视频、音频等多媒体通信；
广播通信；
#### TCP 和 UDP 可以使用同一个端口吗
可以
#### 为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢
为了防止历史报文被下一个相同四元组的连接接收（主要方面）
为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收
#### TCP的三次握手
1. 客户端向服务端发送syn seq=x包 (syn包包括链接使用的原端口，目的端口，目的ip，序号，应答号，对方窗口大小，自己窗口大小，缓冲区)
2. 服务端向客户端发送syn seq=y ack seq=x+1包
3. 客户端发送ack seq=y+1包
#### TCP的四次挥手
1. 客户端向服务端发送fin seq=x包
2. 服务端向客户端发送ack seq=x+1包
3. 服务端向客户端发送fin seq=y包
3. 客户端向服务端发送ack seq=y+1包
#### 第二次握手丢失了，会发生什么？
当客户端超时重传 1 次 SYN 报文后，由于 tcp_syn_retries 为 1，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。
当服务端超时重传 2 次 SYN-ACK 报文后，由于 tcp_synack_retries 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接
#### 第三次握手丢失了，会发生什么？
当服务端超时重传 2 次 SYN-ACK 报文后，由于 tcp_synack_retries 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接
#### 什么是 SYN 攻击？如何避免 SYN 攻击？
我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 SYN 报文，服务端每接收到一个 SYN 报文，就进入SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会占满服务端的半连接队列，使得服务端不能为正常用户服务。
半连接队列，也称 SYN 队列；
全连接队列，也称 accept 队列；
当超过队列最大限制就会丢弃报文
防止syn攻击的方式：
调大 netdev_max_backlog；
增大 TCP 半连接队列；
开启 tcp_syncookies；
减少 SYN+ACK 重传次数

### -------DNS-------
#### 介绍一下DNS以及工作流程
DNS是域名解析协议
工作流程：在地址栏输入www.baidu.com
1. 首先浏览器会去解析这段网址从中取出域名
2. 组建DNS查询报文，并发送到主机的上一级DNS服务器（在开启DHCP协议情况下DNS会自动获取，也可以手动配置）
3. DNS服务器收到这一帧报文时会在自己缓存的DNS池中查找域名所对应的IP，找不到的话会继续向上一级查找，找到了就直接返回，如果最终找不到会返回查询失败
4. 浏览器拿到查询到的ip地址会构建http数据包，最终展示在网页（浏览器会缓存查询到的域名对应的ip并在一定时间内直接使用）
域名结构：www.baidu.com
1. com是最顶级的域名标识公司 
2. baidu表示公司
3. www表示万维网
DNS查询会先从最顶层域名向下查找

### -------DHCP-------
#### 介绍一下DHCP
计算机会通过68,67端口广播DHCP，discover数据包，用于寻找DHCP服务器，家庭网络中路由器就充当了这个角色，这是只有路由器会响应，会在自己的ip地址池中拿到空闲ip
路由器会把这个ip封装成DHCP offer包回复到发起的计算机，这是这台计算机会决定是否使用这个ip（可能收到多个路由器发送的offer包一般使用最先收到的ip）决定好后这台计算机会广播自己的决定
发送request包，路由器会恢复ack包标识接受了请求可以使用当前ip，电脑重启后只需直接确认是否可以使用即可。

### -------ARP-------
#### 什么是ARP
1. osi模型中的网络层协议
2. 是用来将IP地址解析为MAC地址的协议
3. 工作流程：ARP首先会发起一个请求数据包，数据包的首部包含了目标主机的IP地址，然后这个数据包会在链路层进行再次包装，生成以太网数据包，
   最终由以太网广播给子网内的所有主机，每一台主机都会接收到这个数据包，并取出标头里的IP地址，然后和自己的IP地址进行比较，如果相同就返回自己的MAC地址，如果不同就丢弃该数据包。
   ARP接收返回消息，以此确定目标机的MAC地址；与此同时，ARP还会将返回的MAC地址与对应的IP地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。
4. 如果其他计算机修改了ip同样会广播发送免费的ARP数据包，更新ip与mac地址的对应关系。
5. ARP攻击导致无法上网，一台主机发广播送免费的ARP包信息中使用路由器的ip地址，这是该局域网中会更新自己本地的ARP缓存表中的对应关系，这样就会导致其他计算机发送的消息都发送到了这台主机上，这样就会导致无法上完。

### -------ICMP-------
#### 介绍一下ICMP
ICMP协议：互联网控制消息协议（询问报告，差错报告）
询问报告：ping命令的视线
1. 使用ping命令时会记录当前时间并构建ICMP报文
2. ICMP关键报文包括原ip，目标ip，ICMP类型（8表示请求）这些均属于网络层，数据链路层包括原mac地址，目标mac地址
3. 封装好的报文会通过网卡发出去如果目标存在目标主机会收到这个请求
4. 收到请求后会构造回复报文设置ICMP类型（0表示回复）并填写网络层和数据内容的其他信息并发送回原主机
5. 源主机收到回复报文标识目标网络连接成功会再取一次当前时间与发送时间做差打印到控制台，如果目标主机不存在或者发送的包丢了，就会打印超时信息目标主机无法连通。
差错报告：源主机与目标主机中间经历了哪些过程，这些网关的ip地址是多少
使用traceroute命令，就可以检测经过了哪些网管以及对应的ip地址， 在网络数据层ip头中有一个TTL字段（代表此帧数据经历的最大节点数）
1. 假设源主机与目标主机之间有三个路由节点设置UDP报文为一个很大的端口
2. 发送一帧UDP报文设置TTL为1，此时会返回ICMP差错报文，我们就能知道第一台路由器的ip地址并计算出延时
3. 发送一帧UDP报文设置TTL为2，此时会返回ICMP差错报文，我们就能知道第二台路由器的ip地址并计算出延时
4. 发送一帧UDP报文设置TTL为3，此时会返回ICMP差错报文，我们就能知道第三台路由器的ip地址并计算出延时
5. 发送一帧UDP报文设置TTL为3，此时这一帧到达了目标主机，此时会发现目标端口不存在同样会产生一帧ICMP错误报文，这是便可以知道目标主机已经到达，并获取目标主机的相关信息。

### -------webSocket-------
1. 什么事websocket
websocket，是一种网络传输协议，位于OSI模型的应用层。可在单个TCP连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通迅
客户端和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输
从上图可见，websocket服务器与客户端通过握手连接，连接成功后，两者都能主动的向对方发送或接受数据
而在websocket出现之前，开发实时web应用的方式为轮询
不停地向服务器发送 HTTP 请求，问有没有数据，有数据的话服务器就用响应报文回应。如果轮询的频率比较高，那么就可以近似地实现“实时通信”的效果
轮询的缺点也很明显，反复发送无效查询请求耗费了大量的带宽和 CPU资源
2. websocket特点   
   2.1 全双工
   通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合
   例如指 A→B 的同时 B→A ，是瞬时同步的
   2.2 二进制帧
   采用了二进制帧结构，语法、语义与 HTTP 完全不兼容，相比http/2，WebSocket更侧重于“实时通信”，而HTTP/2 更侧重于提高传输效率，所以两者的帧结构也有很大的区别
   不像 HTTP/2 那样定义流，也就不存在多路复用、优先级等特性
   自身就是全双工，也不需要服务器推送
   2.3 协议名引入ws和wss分别代表明文和密文的websocket协议，且默认端口使用80或443，几乎与http一致
3. 相关报文   
   3.1 握手
```
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
```
   Connection：必须设置Upgrade，表示客户端希望连接升级
   Upgrade：必须设置Websocket，表示希望升级到Websocket协议
   Sec-WebSocket-Key：客户端发送的一个 base64 编码的密文，用于简单的认证秘钥。要求服务端必须返回一个对应加密的“Sec-WebSocket-Accept应答，否则客户端会抛出错误，并关闭连接
   Sec-WebSocket-Version ：表示支持的Websocket版本
   3.2 返回的数据格式
```
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat
```
   HTTP/1.1 101 Switching Protocols：表示服务端接受 WebSocket 协议的客户端连接
   Sec-WebSocket-Accep：验证客户端请求报文，同样也是为了防止误连接。具体做法是把请求头里“Sec-WebSocket-Key”的值，加上一个专用的 UUID，再计算摘要
4. 优点
   较少的控制开销：数据包头部协议较小，不同于http每次请求需要携带完整的头部
   更强的实时性：相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少
   保持创连接状态：创建通信后，可省略状态信息，不同于HTTP每次请求需要携带身份验证
   更好的二进制支持：定义了二进制帧，更好处理二进制内容
   支持扩展：用户可以扩展websocket协议、实现部分自定义的子协议
   更好的压缩效果：Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率
5. 应用场景:弹幕,媒体聊天,协同编辑,基于位置的应用,体育实况更新,股票基金报价实时更新
6. websockets角色：每一个事件都分别通过实现onopen onmessage onclose 和onerror函数来处理
open:一旦客户端和服务器之间建立了连接，就会从web socket 实例触发open 事件，这个被称为客户端和服务器之间的初始握手,一旦建立连接就会触发的事件称为onopen事件
message:通常发生在服务器发送一些数据的时候触发该消息事件,服务器发送给客户端的消息可以包括纯文本消息，二进制数据或者图像。但是无论哪种数据都会触发onmessage函数
close:该事件标志着服务器和客户端之间通信结束，当触发onclose事件之后可以关闭连接，同时标记中通信结束，服务器和客户端之间无法进一步传输消息
error:onerror 事件之后总是随后终止连接
actions:当我们想要发生某事件的时候做一些操作，通过用户显示调用的方法有：send()close()
