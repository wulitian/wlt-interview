# 几个重点

#### 自我介绍
面试官您好，很高兴能参加今天的面试，我叫xxx，93的，18年毕业于长春大学计算机科学与技术，曾参加过东北电力大学人工智能技术研究半年，以及浙江大学人工智能学习有证书，
先后在中科结成科技公司与恒生电子共工作6年，结成这家公司主要熟悉的业务是公检法，恒生熟悉的业务是股票债券基金的交易。
工作内容方面主要参与每个项目的 搭建与验证，后续模块任务的指定、文档产出、代码书写、优化、缺陷分析。
前端使用的主要技术栈vue。
#### webpack 包体积优化、打包速度优化、开发环境热更新优化、
##### webpack的开发环境热更新优化
1. 合理的设置source-map类型建议设置为cheap-module-eval-source-map
2. 更少使用loader且loader处理的范围应该要尽量小,HappyPack、ThreadLoader多进程工具也是要慎用，他可能对于启动速度有帮助，但对热更新来说反而是增加负担。
3. 更少使用plugin像分包策略插件、压缩插件、css抽离插件等优化产物类的插件都是不需要的
4. 关掉分包，因为分包也需要进行大量的计算
5. 减少使用console.log打印
6. 开发环境不需要用hash/chunkhash
7. 手动修改路由表，只保留本次所需修改的路由，减少代码量也能有效提高热更新效率
##### webpack打包速度优化
1，限定loader作用范围，比如我们只希望对src文件夹下面内容进行babel转义，node_modules不需要。
```js
 module:{
        rules:[
            {
                test:/\.js$/,
                use:{
                    loader:'babel-loader',
                    options:{
                        presets:[
                            ['@babel/preset-env'],
                        ]
                    }
                },
                // babel转义src文件夹内文件，因为文件夹形式需要使用绝对路径，所以path.resolve(__dirname,'src')
                include: path.resolve(__dirname,'src'), 
                // 当然如果我们只是不想处理node_modules中文件，也可以使用exclude
                exclude: /node_modules/
            }
        ]
    }
```
2，使用resolve.modules指明模块查找时的路径，避免不必要的查找
```js
 module:{
        resolve:{
            // 指明模块查找从下面两个路径开始，src优先于node_modules，这个配置含义是因为正常情况下我们的代码存在src目录下，node_modules中是我们用到的第三方依赖，其他地方基本么有项目用到的代码。
            modules:[path.resolve(__dirname,'src'),/node_modules/]
        }
        rules:[] // 其他loader
    }
```
3，代码书写尽量添加文件后缀名，减少文件匹配resolve.extensions后缀时间。
4，使用高版本webpack，一般版本越高，工具优化越好。
5，使用thread-loader对loader单开线程处理：因为node中webpack是单线程的，使用thread-loader可以对loader处理模块单开线程进行处理，提高打包速度。thread-loader只需要放在耗时的loader前面即可，但不能放在style-loader之前，一般放在style-loader之后，因为thread-loader之后的loader没办法存取文件以及获取webpack的配置
```
 module:{
        rules:[
            {
                test:/\.img$/,
                use:[
                    'thread-loader',
                    'url-loader'
                ]
            }
        ]
    }
```
6，使用cache-loader对loader处理结果缓存到磁盘，二次打包时候读取缓存，提高打包速度。注意：缓存的读写也需要时间，所以只在必要的时候使用。
harder-source-webpack-plugin也可以提升二次打包时间，不过没用过。
```
module:{
        rules:[
            {
                test:/\.ext$/,
                use:[
                    'cache-loader', // cache-loader如果与thread-loader同时出现，先放cache-loader，再放置thread-loader
                    ...otherloaders
                ]
            }
        ]
    }
```
8，当然babel-loader也可以开启缓存处理，将之前转义的结果缓存起来，如果二次打包没有变化，可以直接使用缓存：
```
 module:{
        rules:[
            {
                test:/\.js$/,
                use:{
                    loader: "babel-loader",
                    options:{
                        presets:[['@babel/preset-env']],
                        cacheDirectory: true, // 开启babel-loader缓存 
                    }
                }
            }
        ]
    }
```
9，使用noParse通知webpack哪些模块不需要解析其依赖关系：因为依赖关系解析也是耗时操作，而有些第三方依赖内部肯定不会存在依赖，比如jquery，所以我们可以手动指定这些模块不需要进行依赖关系的解析。(这些模块中没有import，require等模块化的语句，所以不需要解析依赖关系，只需要对其进行打包处理)
```
 module:{
        noParse:/jquery|bootstrap|lodash/, // 匹配当前正则的文的内部不需要进行依赖关系的解析
        rules:[] // 其他loader
    }
```
##### webpack打包的体积优化
1，mode设置成production：生产模式默认会使用tree-shaking删除无用代码，开发模式不会开启tree-shaking
2，开发环境中使用babel-plugin-import插件对组件库按需加载
3，使用splitChunksPlugin将不会变化的第三方库还有共用代码抽离进行单独打包：splitChunks配置前面有写。
4，合理使用url-loader，过大的文件使用file-loader更为合理。对于大图还可以使用image-webpack-loader进行压缩。
5，使用mini-css-webpack-plugin提取css成单独文件，减小主包体积
6，对于不是需要立即获取的资源可以采取异步加载的方式（import().then），异步加载资源也会被单独打包成chunk，减小主包体积。
7，开启@baebl/polyfill使用按需加载，既babel-loader配置presets添加{useBuildsIns:usage}（不指定的话，polyfill会将所有api都实现）
```js
module:{
    rules:[
     {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
            loader: 'babel-loader',
            options: {
                presets: [
                    ['@babel/preset-env'], // 主要翻译工作由@babel/preset-env实现
                    { useBuiltIns: 'usage' } // 开启@babel/polyfill按需加载
                ]
            }
        }
    },
    ]
}
```
#### 脚手架封装
1. 项目结构
首先我们要构建一个基本项目结构其中需要分几个重要的模块包括core,init,command,util,可以使用lerna进行管理，方便多包管理，添加依赖更方便，
这些模块均需要npm link到本地，如果这几个包依赖unit包需要使用file的形式引用，我们上传包的时候也会保持这个目录结构。
2. 需要用到一些库如
commander执行复杂的命令，inquirer问答交互,download-git-repo下载远程镜像，
chalk、colors打印支持各种颜色，cli-spinner实现loading，semver获取版本比较信息
user-home获取用户主目录兼容各个操作系统，
3. 步骤
在package中配置bin指向入口文件，入口文件需要声明node运行环境，npm link后就可以执行这个命令
编写入口文件首先要获取命令的参数process.argv.slice(2)
获取后我们可以对root用户降级，检测用户目录是否有.env，有的话获取到其中的变量，并且生成默认配置.wlt-dev，检测当前当前包的版本，检测更新
开始注册命令，通过commander注册并执行命令，执行命令式我们可以通过spwan来执行js文件，这个js文件就是具体的命令如init,
实现init，首先查询模版，模版类型让用户选择是是组件还是项目，选择后查询接口返回目前远程仓库的有的模版，之后检测本地缓存目录中是否有这个文件，如果有
检测模版版本是否与安装的一致如果一致直接copy这个缓存文件，如果没有下载模版并缓存，如果有但版本不一致则更新，之后通过ejs模版将用户输入的一些内容替换并拷贝到用户安装的目录。
#### 老项目改造接入工程化
##### 为什么要改造
1. 不易维护css，js，dom都是分开或混淆的维护起来麻烦
2. css与js资源多，并且全是采用同步加载的，渲染时需要多次请求，降低了页面的性能，资源的合并: 可以提高加载速度
3. js没有进行压缩
4. 调试代码复杂如果使用jquery的min包时没法配置sourcemap
##### 项目初始化
1. 创建npm 项目
2. 安装webpack依赖
3. 创建js入口文件
4. 创建webpack配置文件
5. 配置package.json
6. 执行npm run build
##### 首页移植,登录页移植
1. 资源文件拷贝
2. 删除index.html
3. 安装html-webpack-plugin
4. 配置html-webpack-plugin
5. 在src/index.js中添加css引用
6. 在src/index.js中添加js引用
7. 调整index.html中的图片路径
8. 添加webpack.ProvidePlugin映射$支持jquery
##### 进阶操作
1. js分离，登录页面与首页打的bundle分离减少资源加载大小,配置多入口与多出口html-webpack-plugin指定对应的chunks
2. 加入webpack-dev-server,提高开发效率，注意需要处理图片路径问题，使用copy-webpack-plugin
3. css分离，使用mini-css-extract-plugin进行分离
4. 压缩js，webpack4使用uglifyjs-webpack-plugin,webpack5使用内置terser-webpack-plugin
5. 压缩css, css-minimizer-webpack-plugin
6. treeShaking(需要满足esm规范,解构可以触发使用lodash时要使用lodash-es,并且mode为production才能生效)
7. 代码分割，
##### 代码实现
```
let path = require('path');
let HtmlWebpackPlugin = require('html-webpack-plugin');
let copyWebpackPlugin = require('copy-webpack-plugin');
let MiniCssExtractPlugin = require('mini-css-extract-plugin');
let TerserPlugin = require('terser-webpack-plugin');
let cssMinimizerPlugin = require('css-minimizer-webpack-plugin');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
let webpack = require('webpack');
module.exports = {
    mode: 'development',
    entry: {
        index: path.resolve(__dirname,'../src/index.js'),
        login: path.resolve(__dirname,'../src/login.js'),
    },
    output: {
        filename: 'js/[name].js',
        path: path.resolve(__dirname, '../dist')
    },
    module: {
        rules: [
            {
                test: /\.css$/,
                use: [
                    MiniCssExtractPlugin.loader,
                    'css-loader'
                ]
            },
            {
                test: /\.ejs$/,
                loader: "ejs-loader",
                options: {
                    esModule: false
                },
            },
            {
                test: /\.png|jpg|jpeg|gif|svg$/i,
                type: "asset",
                parser: {
                    dataUrlCondition: {
                        maxSize: 8 * 1024
                    }
                },
                generator: {
                    filename: 'images/[name].[hash:6][ext]/'
                }
            }
        ]
    },
    devServer: {
        static:{
            directory: path.join(__dirname, 'dist')
        },
        compress: true,
        port: 9000,
        hot: true
    },
    optimization: {
        minimize: true, // 可省略，默认最优配置：生产环境，压缩 true。开发环境，不压缩 false
        minimizer: [
            new TerserPlugin({
                parallel: true, // 可省略，默认开启并行
                terserOptions: {
                    toplevel: true, // 最高级别，删除无用代码
                    ie8: true,
                    safari10: true,
                }
            }),
            new cssMinimizerPlugin(),
        ],
        splitChunks: {
            chunks: "all",
            minSize: 300 * 1024,
            name: 'common',
            cacheGroups: {
                jquery: {
                    name: 'jquery',
                    chunks: "all"
                }
            }
        }
    },
    plugins: [
        new HtmlWebpackPlugin({
            filename: "index.html",
            template: "./src/index.html",
            chunks: ['index']
        }),
        new HtmlWebpackPlugin({
            filename: "login.html",
            template: "./src/login.html",
            chunks: ['login']
        }),
        new copyWebpackPlugin({
            patterns: [{
                from: path.resolve(__dirname, '../src/img'),
                to: path.resolve(__dirname,'../dist/img')
            }]
        }),
        new MiniCssExtractPlugin({
            filename: 'css/[name].css',
            chunkFilename: 'css/[name].chunk.css'
        }),
        new CleanWebpackPlugin({}),
        new webpack.ProvidePlugin({
            $: 'jquery',
            jQuery: 'jquery',
        })
    ]
}
```
#### RBAC实现权限管理
##### RBAC
1. 模型是一种常用的权限控制模型，用于管理和控制用户对系统资源的访问权限。在 RBAC 模型中，访问权限是通过角色而不是直接与用户关联来进行管理的。
   用户（User）：用户代表系统中的实体，可以是个人用户或其他应用程序。用户通过被分配角色来获得相应的权限，从而决定其在系统中能够执行的操作。
   角色（Role）：角色代表了一组相关权限的集合，通常与用户的职能、责任或角色相对应。每个角色拥有特定的权限，定义了该角色所能执行的操作。
   权限（Permission）：权限是指用户对系统资源的访问能力。它可以是操作级别的，如读取、写入、删除等，也可以是对象级别的，如访问特定文件或数据库。
2. RBAC工作原理
   把权限赋予角色，再把角色赋予用户，用户就拥有了角色所对应的权限。用户拥有的权限等于他所有的角色持有权限之和。
3. RBAC的几种模型
   默认为RBAC0
- RBAC1 在 RBAC0 的基础上，进行了 角色分层。通过给角色划分等级，每个等级拥有不同的权限，从而实现了更细粒度的权限管理。这种角色的分层让权限的分配更加灵活，可以根据具体需求来调整角色等级和相应的权限。
- RBAC2 RBAC2 在 RBAC0 的基础上增加了 RBAC 的 约束模型。具体来说，这些限制可以分成两类，即静态职责分离（SSD）和动态职责分离（DSD）。通过这些约束模型，RBAC2 能够更好地保证权限的安全性和稳定性。
  静态职责分离（SSD） 主要是对用户、角色和权限三者之间增加了一些限制，例如互斥角色和基数约束。在 SSD 中，一些特定的角色不能被分配给同一个用户。例如，同一用户不能被分配 “管理员” 和 “普通用户” 这两个互斥角色。另外，对于用户拥有的角色数量也有限制，即一个用户拥有的角色是有限的。在一些场景中，例如公司或组织的实际运营中，不同的职位或角色之间具有一定的排他性，不能同时由同一人担任。通过 SSD，我们可以保证这种排他性得以实现。
  动态职责分离（DSD） 主要是在会话和角色之间增加限制。具体来说，DSD 可以动态地约束用户拥有的角色。例如，一个用户可以有多个角色，但是在一次会话中只能激活一个角色。这种动态的约束可以防止用户在会话中同时激活多个角色，从而保证系统的安全性。
- RBAC3 是 RBAC2 和RBAC1的合集，所以它 既包含了角色分层，也包括了可以增加的各种约束。因此，RBAC3是这四种模型中最为全面和复杂的权限管理模型。可以实现更为精细和安全的权限管理。
##### 前端权限控制的实现
1. 接口权限:
   接口权限目前一般采用jwt的形式来验证，没有通过的话一般返回401，跳转到登录页面重新进行登录,登录完拿到token，将token存起来，通过axios请求拦截器进行拦截，每次请求的时候头部携带token
2. 路由权限:
   方案一: 初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验
   这种方式存在以下四种缺点：
   加载所有的路由，如果路由很多，而用户并不是所有的路由都有权限访问，对性能会有影响。
   全局路由守卫里，每次路由跳转都要做权限判断。
   菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译
   菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识
   方案二:初始化的时候先挂载不需要权限控制的路由，比如登录页，404等错误页。如果用户通过URL进行强制访问，则会直接进入404，相当于从源头上做了控制
   登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用addRoutes添加路由
   这种方式也存在了以下的缺点：
   全局路由守卫里，每次路由跳转都要做判断
   菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译
   菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识
3. 按钮权限:
   方案一: 按钮权限也可以用v-if判断,但是如果页面过多，每个页面页面都要获取用户权限role和路由表里的meta.btnPermissions，然后再做判断
   方案二: 通过自定义指令进行按钮权限的判断
4. 菜单权限:
   方案一: 菜单与路由分离，菜单由后端返回
   前端定义路由信息,name字段都不为空，需要根据此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有name对应的字段，并且做唯一性校验,全局路由守卫里做判断
   每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的name与路由的name是一一对应的，而后端返回的菜单就已经是经过权限过滤的
   如果根据路由name找不到对应的菜单，就表示用户有没权限访问
   如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过addRoutes动态挂载
   这种方式的缺点：
   菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用
   全局路由守卫里，每次路由跳转都要做判断
   方案二: 菜单和路由都由后端返回,前端统一定义路由组件在将后端返回路由通过addRoutes动态挂载之间，需要将数据处理一下，将component字段换为真正的组件
   如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段，前端拿到数据也要做相应的处理
   这种方法也会存在缺点：
   全局路由守卫里，每次路由跳转都要做判断
   前后端的配合要求更高
#### 高级查询组件封装
1. 功能需求分析：
明确需求：确定需要支持的查询功能，如字段选择、条件设置（包括操作符和值）、逻辑关系（与、或）、排序等。
用户界面设计：设计用户友好的查询条件输入界面，包括输入框、下拉菜单、复选框等元素。
2. 组件结构设计：
拆分为组件：根据功能和界面的不同部分，将查询组件拆分为适当的子组件，例如字段选择组件、条件设置组件、逻辑关系组件等。
Props 设计：设计每个子组件需要的props，包括数据源（字段列表）、事件回调（执行查询、重置等）。
3. 数据模型设计：
查询条件模型：定义一个数据模型来表示和存储用户输入的查询条件，可以是一个对象或者数组，每个元素表示一个条件，包括字段名、操作符、值等信息。
动态条件管理：支持动态添加、删除和编辑查询条件，确保用户可以根据需要灵活调整查询条件。
4. 用户交互与事件处理：
字段选择：提供下拉菜单或自动完成输入框，让用户选择查询字段。
条件设置：根据字段类型（文本、数字、日期等）提供合适的操作符和输入控件（文本框、日期选择器等）。
逻辑关系：允许用户设置多个条件之间的逻辑关系（与、或），以支持复杂的查询逻辑。
查询与重置：提供按钮或快捷键执行查询和重置查询条件的功能。
5. 查询逻辑实现：
构建查询参数：根据用户输入的条件构建查询参数，可以是一个包含条件的对象或字符串。
查询执行：通过回调函数将构建好的查询参数传递给父组件或调用应用程序的查询接口执行实际的查询操作。
结果展示：可选的，在组件内部或外部展示查询结果，以便用户查看和操作。
6. 错误处理与验证：
输入验证：对用户输入的查询条件进行验证，确保输入的值符合预期的数据类型和格式。
错误处理：处理用户可能出现的输入错误或不合法的操作，给出明确的提示或反馈。
7. 测试与优化：
单元测试：编写单元测试，验证组件各个部分的功能正确性和边界情况处理。
集成测试：确保组件与应用程序的其他部分正常集成和交互。
性能优化：优化查询组件的性能，尤其是在处理大量数据或复杂查询条件时的响应速度。
8. 文档编写与发布：
组件文档：编写清晰的组件文档，包括组件的使用方法、API接口、示例代码等。
发布到仓库：将封装好的组件发布到适当的仓库或平台，如npm、GitHub等，便于其他开发者使用和贡献。
#### websocket实现通讯
WebSocket 是一种在单个 TCP 连接上提供全双工通信的协议，它能够在客户端和服务器之间实现实时的双向通信。其原理可以简单总结如下：
##### 握手阶段：
客户端通过 HTTP 或 HTTPS 发起与服务器的连接请求。
如果服务器支持 WebSocket，它会在 HTTP 头部中包含特定的协议升级请求（Upgrade: websocket）。
客户端收到服务器的确认后，会发送一个协议升级请求（Upgrade: websocket），表明希望将连接升级为 WebSocket 连接。
握手成功后，连接从 HTTP/HTTPS 协议转换为 WebSocket 协议，后续的通信不再遵循 HTTP/HTTPS 的请求-响应模式。
##### 建立连接：
一旦握手成功，客户端和服务器之间就建立了持久化的连接。
连接建立后，WebSocket 允许双向通信，即客户端和服务器都可以通过同一个连接发送消息给对方。
##### 数据传输：
WebSocket 使用帧（frame）来传输数据，帧可以是文本帧或二进制帧。
文本帧允许发送 UTF-8 编码的文本数据，而二进制帧可以用于传输任意的二进制数据。
每个帧都包含了一些控制信息（例如标志位和长度），这些信息使得 WebSocket 能够处理不同类型的数据和控制消息。
##### 实时性：
WebSocket 的双向通信机制使得客户端和服务器能够实时地发送和接收消息。
服务器可以随时向客户端发送更新的数据，而不需要客户端显式地发起请求。
这种特性使得 WebSocket 非常适合实时应用程序，如聊天应用、在线游戏、股票市场更新等。
##### 关闭连接：
当客户端或服务器决定关闭连接时，它们可以发送一个特殊的帧来表示关闭连接的意图。
正常关闭连接时，双方会发送一个关闭帧（Close frame），并等待对方响应，确认连接已关闭。
总结来说，WebSocket 的原理是利用单个 TCP 连接来实现客户端和服务器之间的持久化双向通信，通过帧来传输数据和控制信息，从而实现实时通讯的需求。
##### 具体步骤
1. 前端准备：
在前端页面上，使用 JavaScript 创建一个 WebSocket 客户端连接。
当连接建立后，通过 WebSocket 接收来自服务器的数据更新。
2. 服务器端实现：
在服务器端，通过后端语言（如Python、Node.js等）实现一个 WebSocket 服务器。
服务器端负责监听数据源（如数据库变化、实时事件等），并将新的统计数据推送给连接的客户端。
3. 数据传输：
客户端通过 WebSocket 接收到服务器发送的统计数据更新。
可以使用图表库（如Highcharts、Chart.js等）动态更新页面上的统计图表，展示最新的数据。
4. 实时性与性能考虑：
WebSocket 提供了低延迟、高效率的双向通信机制，适合实时展示统计图这类需求。
服务器端需要考虑如何高效地获取和处理数据源，确保数据的实时性和准确性。
客户端图表库应当支持动态更新，能够根据收到的新数据实时更新图表，提供流畅的用户体验。
5. 安全性考虑：
在实现 WebSocket 时，需要注意安全性问题，如防止恶意攻击和未经授权的访问。
可以考虑使用安全的 WebSocket 协议（如wss://），以及对数据进行加密和验证，确保通信安全可靠。
6. 处理断开连接和重连：
在客户端和服务器端都应考虑连接断开和重新连接的情况，确保系统的稳定性和可靠性。
可以通过实现心跳机制或监控连接状态来处理断开连接并尝试重新连接。
#### 缺陷分析流程结合人工智能
基于数据相似度来分析缺陷，跟依赖于精细其他开发人员的记录，训练出数据模型，之后根据任务描述，匹配出相似度前10的问题，也就是说开发这类任务其他开发遇到过得问题，可以在派发任务时
更清晰的标注出来注意点。
#### 根据目前情况技术选型
1. 前端的项目目前来看主要分为小程序开发，H5页面开发、PC官网、后台管理系统开发、Native开发。不同的项目所涉及的知识点和环境不太一样，但是很多方面是相通的。
   小程序:由于框架限定在Vue，所以这里指的是使用mpvue、WePY来开发小程序项目。
   H5页面:这里主要是指微信页面、Webview中的H5页面开发
   PC官网:为什么单独划出来是因为官方的开发主要是用来展示企业信息、产品，对交互、体验有一定的要求，会有一些炫酷的动画效果。还有就是官网有可能需要采用SSR（比如Vue的Nuxt.js）来做，来确定良好的SEO。
   后台管理系统:后台管理系统主要功能在于数据的配置、权限的控制、数据报表的展示、日志功能等。通常又叫CMS，OA。
   Native开发:这个通常就是指用前端技术去开PC应用、APP应用，比如Weex, Electron。
   通吃型:比如uni-app， 可以一套代码编译成不同的平台源码。 不同的项目类型决定了其能够使用的生态、目录结构、特定的上下文。这里就以后台管理系统为例,来说一下如何基于Vue来搭建一个项目。
2. 基于@vue/cli的选型
   2.1 后台管理系统中vue-router，vuex都是必选的，其它可以自行考虑
   2.2 ES6/7 or Typescript ?
   鉴于目前Typescript如此流行，很多流行的框架和库都采用其来写，IDE友好的智能提示、强类型结束等，在立项时是否考虑采用Typescript来写Vue项目。如果采用Typescript，是不是很羡慕Angular中的DI注入，那可以考虑在大型项目中引入inversify这个库；在开发过程中遇到一些库没有声明文件要学会定义声明文件，这个是Typescript初学者最头疼的问题。
   还有一个问题是团队中有多少人会Typescript，项目周期紧不紧，有没有时间来试错，踩坑。
   2.3 Sass/Less/Stylus/PostCss ?
   由于Vue项目开发本身样式自带scope，所以不需要像React那样去选css-in-js框架（目前在React最流行的是styled-components），但是如果我们在Vue中采用JSX的方式来定义组件，是否考虑引入vue-styled-components这个库（年久失修，完全脱节React版了，但依然是Vue中最好的选择）。在Vue中sass, less, stylus可以在`<style>`标签中通过lang=""来指定，如果你想使用PostCss也可以的，就是要自己花点时间去折腾一下。
   2.4 关于代码规范和风格
   这个主要的选择就是Prettier 和 Airbnb风格，如果配置不好，在IDE中满屏的红色波浪线和黄色的小灯光提示。
   在配置eslint或者tslint时主要考虑的点是是否要写分号，未定义变量等问题。
   2.5 关于测试
   很多时间前端项目测试反而拖慢了项目的开发进度，但是在开源项目中良好的测试是保证项目质量的一个很重要方式。这里通常分为单元测试(Unit Testing)和端到端测试(E2E Testing),一般选择jest
3. 通用配置
   3.1 编辑器配置：.editorconfig这里最重要的是缩进方式，及Tab大小，建议2个空格作用缩进。
   3.2 Git忽略文件配置: .gitignore这里的配置决定了哪些文件会被版本控制所忽略
   3.3 Eslint配置: .eslintrc.js，.eslintignore
   3.4 PostCss配置: postcss.config.js这个文件自动生成，里面的内容就是指定autoprefixer兼容配置
   3.5 Babel配置: babel.config.js主要是配置Babel的plugins、presets和parse等
   3.6 StyleLint：.stylelintrc如果代码对样式有一定的规范的话，可以加一个，没有就不需要配置这个。
```
   {
      "extends": "stylelint-config-standard",
      "plugins": ["stylelint-scss"]
   }
```
3.7 @vue/cli配置：vue.config.js，在这个里面我们可以对@vue/cli的Webpack进行配置和覆盖。
3.8 Webpack配置：webpack.config.js因为在webpack中不能识别@vue/cli中的@路径，所以需要一个配置文件让webpack提示正常。具体怎么配置可以自行搜索
4. 版本控制：不管是多人协作开发还个一个人开发在使用git时都需要一套流程规范来执行。
   4.1 Git Flow
   这个每个团队的做法不太一样，有的采用多分支开发，有的采用单一master分支开发，有的还采用submodule的方式，有的在项目中使用了lerna来做多packages，甚至有的公司一个分支一个项目。
   在开发环境的区分上通常分为生产（线上）环境、预发布环境、开发环境，有的还有什么沙盒环境，很多做得好的公司基于Docker前后端都可以根据每一个commit来发布。
   有时候不想把有些代码提交上去，除了选择性提交单个文件外，还有使用git的stash功能，此外如果使用Webstorm可还可以使用其提供的Changelist来缓存修改，切换分支。
   4.2 Git Commit
   项目提交的描述如果没有一定的规范，随性而为的话，就会让其它人误解。通常提交采用英文作为描述，可以多行文字。在社区中有很多流行的方案(比如Conventional Commit)，更多的是采用Angular的方式。
   4.3 Change Log
   如果采用了社区统一的commit方式，那么我们就可以基于提交来生成变更记录，在每一次版本发布时自动关联Jira中的Issue。
   4.4 版本号生成
   这个通常是按照Semantic Versioning的规范来打tag，具休怎么做可以自行尝试
   在项目中通常使用gitHooks和husky这二个node包来配置上面提到的这些。在git钩子中我们在每次提交、push前跑一次单元测试、代码覆盖率。前端代码覆盖率一般来说没有必要加，不然很痛苦。
5. 项目文档和组件测试文档  
   除了在项目根目录放一个README.MD文件外，通常还需要一些比如CHANGELOG.md, PLAD.md等文档，还有一些组件的使用文档，可以考虑使用styleguide和storybook。
6. 持续集成和部署  
   目前开源项目通常采用Travis，而一般公司内部项目通常采用Jenkins来做持续集成，在部署上通常采用Docker，集群上使用KubeOperator来管理。或者github action
7. API请求方式
   通常采用Restfull的方式来请求数据，也可以采用GraphQL的方式来请求。如果采用Restfull的方式通常可以使用axios, fetch api。GraphQL可以使用Apollo Client。
8. 代理和数据Mock
   SPA页面开发通常都是配置代码来调用后端的接口数据，怎么配置可以参考@vue/cli文档。数据Mock主要用到一个mockjs
9. 项目用到的库
   UI框架: Element, iView, vue-strap等,注：UI风格目前有Bootstrap、Antd和Google Materials三种风格，在项目搭建时这也是一个很重要的技术选型。
   日期: moment, dayjs
   URL解析: query-string, path-to-regexp
   实用方法: lodash
   Cookie: js-cookie
   混淆ID: hashids
   图表: echarts
   Ajax: axios, isomorphic-fetch, vue-apollo
   拖拽: Vue.Draggable
   Meta修改: vue-meta
10. 项目目录划分
    视图页面放在 pages或者views中
    静态文件放在static中
    资源文件放在assets中
    样式文件放在styles中
    辅助库放在utils中
    配置文件可以放在config或者constants中
    vuex的文件放在stores中，至于getters, actions, mutation, modules可以参考vuex的文档
    路由文件放在routes中
    所有组件放在components中
    共享代码也可以使用shared作为目录
    布局组件可以放在layouts目录中
11. 权限配置   
    主要分为页面权限（路由）、功能权限，采用多级角色划分方式。菜单配置数据直接通过接口返回
#### 优化百万级清单展示
首先我们要得到container节点，container-list节点，startIndex,endIndex,renderList,scrollStyle，dataSource,itemHeight,viewHeight,maxCount
计算这些项其中viewHeight根据container.offsetHeight获取，其他项均可以通过计算获取。其中style采用transform:translateY与height来实现滚动效果，
高度计算是dataSource*itemHeight - startIndex*itemHeight,纵轴偏移量就是 startIndex*itemHeight
1. 理解虚拟滚动的原理：
虚拟滚动通过只渲染可见区域的数据项来优化性能，而不是一次性渲染整个数据集。当用户滚动时，动态地更新可见区域的数据，从而减少页面渲染的数量和复杂度。
2. 数据源准备：
确保有一个完整的数据源，可以是数组或者其他数据结构。这些数据可以是从服务器获取的，也可以是在客户端静态定义的。
3. 页面结构设计：
设计包含滚动容器和数据项的页面结构。滚动容器应该有固定的高度或者最大高度，并设置 overflow: auto 或 overflow: scroll 属性来实现滚动效果。
4. 动态计算可见区域：
根据滚动容器的高度和每个数据项的高度（如果数据项高度不一致，则需要额外处理），计算可见区域可以容纳的数据项数量。
5. 滚动事件监听：
监听滚动容器的滚动事件。根据滚动位置计算当前可见的数据项范围。
6. 条件渲染数据项：
根据计算出的可见数据项范围，动态地渲染相应的数据项到页面上。这可以通过直接操作DOM元素或者使用现代前端框架（如React、Vue等）的虚拟列表组件来实现。
7. 性能优化：
缓存数据项的高度：如果数据项高度一致，可以缓存每个数据项的高度，避免重复计算。
批量渲染和更新：在滚动时批量更新可见区域的数据项，而不是每次滚动都进行单个数据项的更新。
利用CSS优化：使用CSS属性如 transform 或者 translate 来优化滚动性能，避免频繁重排和重绘。
8. 边界处理：
处理边界情况，例如在滚动到顶部或底部时，确保正确显示数据。
#### 前端监控SDK，日志记录
##### 数据采集
1. 性能监控
FP:new PerformanceObserver观测paint其中first-paint(白屏时间)
FCP:new PerformanceObserver观测paint其中first-contentful-paint(首次内容绘制时间)
LCP:new PerformanceObserver观测largest-contentful-paint(最大内容绘制)
onload: 监听window.addEventListener('load', callback, true)获取performance.now()
DOMContentLoaded: 监听window.addEventListener('DOMContentLoaded', callback, true)获取performance.now()
资源加载时间：通过PerformanceObserver来获取dns时间，tcp时间，资源加载耗时等
接口请求耗时：重写XMLHttpRequest获取方法信息，请求时拦截到请求参数信息
6. 错误监控
资源加载错误：通过window.addEventListener('error',fn)可以获取时间，页面位置等
js错误：window.onerror事件获取错误信息
promise错误：window.addEventListener('unhandledrejection',fn)获取相关信息
7. 行为监控
pv,uv：前端只能监控到pv，用户信息与进入时间performance.now()
页面停留时长：在跳转到其他页面时获取performance.now()
用户点击：异步将点击信息上传，包括点击横纵坐标与点击的dom元素，点击的页面
##### 数据上报
1. 上报方法
xhr
image，
sendBeacon，浏览器window.navigator.sendBeacon.bind(window.navigator)
2. 上报时机
延时上传setTimeout
达到缓存上限上传
跳转页面前上传
#### 实现拖拽制作图表并供客户使用
实现一个编辑器可以填加图片、文本、echarts，最终生成页面，手机端可以查看，主要实现了拖拽元素，改变元素大小，快捷键删除、拷贝、粘贴、动态编辑当前元素实时展示
主要用的几个库vue3+ts、ant-design-vue、uuid、vue-draggable-resizable、hotkeys、lodash等库
#### 实现一键换肤
1. 样式替换法，当使用某一个主题时就将当前所有的样式进行覆盖
2. 动态修改elementUi的sass颜色变量，通过阅读sass中定义的常量可以得到关于primary的默认颜色定义，
   首先拿到用户修改的颜色生成primary相关颜色，根据css-color-function这个库生成对应用户设置的多个颜色，
   获取当前版本elementui的index.css，把默认的颜色替换成对应的键，再把用户新设置的颜色转换后的多个颜色替换进去
   动态添加style标签在最后，为了避免重复添加可以做一下判断，同时我们可以记录当前颜色到本地存储，默认从缓存中读取没有再取获取，
   上面的请求也可以缓存结果，不用每次都去请求。
3. 将官方提供的变量整理出几套通用的颜色主题，定义好主题报错的css名字，借助glup生成几套皮肤样式，当切换时动态加载css文件，我们可以借助本地缓存缓存当前加载的路径
#### 实现大小屏幕适配
##### 响应式设计
1. 什么是响应式：一个网站兼容多个终端而不是为每个终端都定制特定版本
2. 响应式基本原理：基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理
3. 响应式优点：面对不同分辨率设备灵活性强、能够快捷解决多设备显示适应问题。
4. 响应式缺点：兼容各种设备工作量大，效率低下、代码累赘，会出现隐藏无用的元素，加载时间加长、其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果一定程度上改变了网站原有的布局结构，会出现用户混淆的情况。
5. 如何兼容低版本ie：media-queries.js 或 respond.js等
```html
<!--[if lt IE 9]> <script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script> <![endif]-->
```
6. 响应式步骤：
- Meta 标签：为了适应屏幕，多数的移动浏览器会把HTML网页缩放到设备屏幕的宽度。你可以使用meta标签的viewport属性来设置。下面的代码告诉浏览器使用设备屏幕宽度作为内容的宽度，并且忽视初始的宽度设置。这段代码写在 <head>里面
```html
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```
- html结构
- Media Queries:响应式网页设计的关键告诉浏览器如何根据特定的屏幕宽口来加载网页
```css
@media screen and (max-width: 300px) {
    body {
        background-color:lightblue;
    }
}
```
##### rem布局实现
移动端实现响应式一般根据设计稿宽度除以10设置成字体大小，此时1rem就等于这个字体的大小，实现内部盒子时根据设计稿中盒子的像素计算出实际的rem之后进行设置，在实现手机屏幕等比例放大可以考虑使用rem
#### i18n语言包支持国际化
1. 安装vue-i18n
2. 配置中英文语言包
3. 配置i18n并挂载到vue上其中locale选项可以从本地存储中获取默认设置成中文
4. 组件中可以使用`$t('json中的变量')`获取
5. 页面实现切换多语言事件传递zh,en，并存储到本地存储并且将this.i18n.locale设置成对应的值
#### 实现图片懒加载
核心就是判断一个元素是否在可视区域，加载方面配合图片的属性loading="lazy",将src设置给data-src,当图片出现在可视区域时将data-src赋值给src,
事件方面监听scroll（优化可以通过防抖），或者 IntersectionObserver（优点不会频繁触发）
1. img的loading属性设为“lazy”
```
<img data-src="deathghost.jpg" loading="lazy" alt="wulitian" />   
```
2. 可视区域的实现方法
2.1 offsetTop - scrollTop < = innerHeight
    clientWidth：元素内容区宽度加上左右内边距宽度，即clientWidth = content + padding
    clientHeight：元素内容区高度加上上下内边距高度，即clientHeight = content + padding
    scrollWidth 和 scrollHeight 主要用于确定元素内容的实际大小
    scrollLeft 和 scrollTop 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置
    垂直滚动 scrollTop > 0
    水平滚动 scrollLeft > 0
    将元素的 scrollLeft 和 scrollTop 设置为 0，可以重置元素的滚动位置
2.2 getBoundingClientRect
   该api返回值是一个 DOMRect对象，拥有left, top, right, bottom, x, y, width, 和 height属性
3. 事件方面
   3.1 监听scroll
   3.2 IntersectionObserver 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比getBoundingClientRect会好很多
3. vue插件
```
npm install vue-lazyload --save

// main.js 文件
import VueLazyload from 'vue-lazyload'
// Vue.use(VueLazyload) //无配置项
// 配置项
const loadimage = require('assets/img/common/loading.gif')
Vue.use(VueLazyload, {
 preLoad: 1.3, //预加载的宽高比
 loading: loadimage, //图片加载状态下显示的图片
// error: errorimage, //图片加载失败时显示的图片
 attempt: 1, // 加载错误后最大尝试次数
})
// img元素上使用v-lazy="src";<img v-lazy="showImage"/>
```
#### 实现禁止F12避免他人进行代码调试
1. 无限 debugger(ctrl+f8可以关闭)
2. 终极版(可以监听窗口变化事件进行触发)
```
(() => {
  function block() {
    if (window.outerHeight - window.innerHeight > 200 || window.outerWidth - window.innerWidth > 200) {
      document.body.innerHTML = "检测到非法调试,请关闭后刷新重试!";
    }
    setInterval(() => {
      (function () {
        return false;
      }
      ['constructor']('debugger')
      ['call']());
    }, 50);
  }
  try {
    block();
  } catch (err) { }
})();
```
3. 禁止右键菜单
```js
document.oncontextmenu = function () {
    return false;
};
```
4. 禁止F12快捷键
```
document.onkeydown = function (e) {
 if (e.keyCode === 123) {
     return false;
 }
};
```
5. 检测开发者工具
```
setInterval(function () {
    if (typeof console.clear !== 'undefined') {
        location.reload();
    }
}, 1000);
```

#### 摊位管理系统的设计
这是一个2c类的产品，便于城管管理的这么一个系统
使用方是摆摊的群体，城管群体，摆摊的关注如何快速预约摊位，转让摊位，城管关注各个摊位使用情况，是否本人等情况，
主要工作流程就是城管会在摆摊时间点，核查摊位情况，摆摊这会展示手机二维码，城管扫码后会在移动警务上核查现场情况。保障市场的稳定有序。
使用方分别所在的终端为手机，移动警务设备，pc端管理基于这些为前提下我们进行各端设计与实现。我们手机端采用uniapp，pc端采用vue+iview的方式，
组织架构可以采用公司已有子项目作为基础开发，组织权限架构，权限这块主要就是需要按照地区，为当地城管分配管理权限，
划分功能，摊位管理，市场管理，账户信息，权限管理，租户管理等。

#### 接口防刷
1. 防火墙：配置防火墙规则，限制对API接口的访问频率和来源IP，防止大量无效请求。
2. 验证码：在需要保护的接口添加验证码，要求用户先验证再访问
3. ip限制：仅限特定的ip范围
4. 接口访问频率限制，规则可以自己设计
5. 日志监控：监控API接口的访问日志，及时发现异常请求，例如某个IP频繁请求同一接口，及时采取相应的安全措施。
6. 安全加密，对敏感数据安全加密
7. 使用api网关，进行过滤，鉴权，限流，保护api安全
#### 无感刷新 token 是怎么实现的？
实现无感刷新主要是需要知道什么时候需要刷新，token失效时访问接口会报401此时就需要刷新token，我们可以在前端请求的拦截器中
调用刷新token接口，并将本地原有token替换，拦截的内容由之前的请求参数重新发请求带上新的token即可，还有一种就是可以开启另一个webWork线程
根据token有效期，比如token30分分钟过期我们可以25分钟刷新一次并存储到本地，优化做法，就是在25分钟内有操作就才会刷新。
#### 如何实现上拉加载，下拉刷新？
上拉加载:scrollTop + clientHeight >= scrollHeight
下拉刷新:监听原生touchstart事件，记录其初始位置的值，e.touches[0].pageY；
监听原生touchmove事件，记录并计算当前滑动的位置值与初始位置值的差值，大于0表示向下拉动，并借助CSS3的translateY属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；
监听原生touchend事件，若此时元素滑动达到最大值，则触发callback，同时将translateY重设为0，元素回到初始位置
#### icon 图片怎么引入
引入alibaba图标库，引入css,js直接可以使用。
#### 一个网页从请求到呈现花了很长时间，如何排查
首先我们可以打开控制台看一下接口耗时，确定一下是不是网络问题，如果不是看一下接口耗时，如果耗时时间长可以优化一下接口，
如果不是接口问题，我们可以看一下性能分析工具找以下具体耗时在那里，也有可能是cpu占用率过高。dns解析慢，js阻塞，等
#### React、Vue 和 JQuery 在什么场景下怎么选型
应用需要尽可能的小和快就用vue，vue渲染速度比react快
大型项目建议用react，因为vue模板的使用不容易发现错误、也不易拆分和测试
如果要适用于web和原生app的项目，就使用react native
如果一些老项目需要一些兼容性可以考虑jquery
#### iOS 下软键盘输入框遮挡遇到过问题么？怎么解决顶不起来的问题？
我们需要在键盘弹起后，计算可视区的高度，并将最外层容器高度赋值为可视区高度
我们需要禁用全局的滚动，但对一些需要滚动的区域需要放开，比如中间的列表部分
#### 怎么从十万个节点中找到想要的节点，怎么快速在某个节点前插入一个节点？
bfs广度优先搜索找到这个节点，根绝这个节点找到父节点，根据父节点找到所有子节点的索引，根据索引插入就行了
#### 有一个一亿长度的字符串，怎么存储设计可以让它更好去查询、修改？
分割存储：将长字符串分割为多个较小的片段，每个片段分别存储，并使用索引来记录每个片段的位置。查询时可以根据索引定位到对应的片段，并进行相关操作。
压缩存储：使用压缩算法对长字符串进行压缩，减小存储空间。在查询和修改时，需要先进行解压缩操作，对解压后的字符串进行操作。
分块存储：将长字符串分为多个块，每个块都有唯一的标识符。可以使用数据库或者文件系统等存储系统来存储这些块，通过标识符进行索引和查询。在修改时，只需修改对应的块，而不必修改整个字符串。
#### 怎么用原生 js 实现一个轮播图，以及滚动滑动
1. 利用绝对定位absolute偏移量的改变来实现具有往左往右滑动的效果
2. 利用 display/opacity/visibility状态切换来实现没有往左往右滑动的效果
3. 存储每个图片的位置信息（absolute位置信息+z-index属性+opacity透明度 等等）到一个数组。对数组进行pop push shift unshift等操作再引用到DOM元素上，产生轮播效果。
#### 怎么计算在一个页面上的停留时间
DOMContentLoaded 事件或 onload 事件,window.addEventListener(pageshow,function(){})这几种方式可以记录进入的时间
window.addEventListener('unload',function() {})window.addEventListener('pagehide',function() {})这两种方式可以计算停留的时间。
#### 给你一亿个数，是连续的，怎么找出两个不存在的数
二分查找法
#### H5 页面中长列表在下拉过程中为什么会闪一下 ，如何解决？
页面重绘频繁： 由于大量 DOM 元素的变动，浏览器频繁重绘页面，导致闪烁现象。
图片或资源加载不完全： 列表中的图片或其他资源未加载完全，当下拉时，这些资源加载完成后导致页面重绘，产生闪烁。
样式表或脚本文件加载顺序问题： 如果样式表或脚本文件加载顺序不当，可能会在加载过程中导致短暂的无样式或无脚本状态。
JavaScript 操作 DOM： 频繁的 DOM 操作，如插入或删除大量元素，可能导致页面闪烁。
渲染阻塞： 页面中其他元素或脚本的执行阻塞了渲染进程，导致闪烁。
解决方法
使用虚拟列表
使用懒加载
css动画替代js动画
减少dom操作
使用Gpu加速如transform：translate()
#### 前端给页面加水印，说说各种编码的特点，说说数字签名的特点
1. 可以通过写一些div内容设置透明度，设置不可选中，设置透过点击来实现
2. 可以使用canvas绘制图片时将内容填充上，之后根据canvas获取url重新赋值给图片
3. 将svg设置成背景图
   注意为了避免通过控制台将水印去掉，可以禁止调试，或者定时监测，如果发现没有了，就添加水印
#### 如何监听线上页面内存溢出？
1. 使用浏览器开发者工具 Chrome DevTools提供了一些工具来帮助检测和诊断内存问题：
   Performance 面板：记录和分析页面的性能。
2. performance.memory API 可以提供关于内存使用的信息。
```
if (performance.memory) {
    const memory = performance.memory;
    console.log(`Used JS heap size: ${memory.usedJSHeapSize}`);
    console.log(`Total JS heap size: ${memory.totalJSHeapSize}`);
    console.log(`JS heap size limit: ${memory.jsHeapSizeLimit}`);
}
```
可以定期记录这些信息来监控内存使用情况。 使用 setInterval 进行监控 你可以设置一个定时器来周期性地检查内存使用情况：
3. 使用外部监控工具
4. 检测内存泄漏的方法,定时内存快照,你可以在应用的关键点或定时器中拍摄内存快照，比较快照之间的差异，找出可能的内存泄漏。
   使用 WeakMap 和 WeakSet避免内存泄漏的一个有效方法是使用 WeakMap 和 WeakSet，它们允许对象在不再被引用时被垃圾回收。
5. 监控特定功能如果你知道某些功能可能导致内存泄漏，可以在这些功能中添加监控代码。例如，在 AJAX 请求完成后检查内存使用情况：
#### 有没有了解过拖拽？觉得它有哪些难点？
监听鼠标事件：监听mousedown、mousemove和mouseup事件，分别用于捕获拖拽开始、拖拽中和拖拽结束的动作。
计算偏移量：在mousedown事件中，计算鼠标指针与组件元素的相对位置，即偏移量。
更新组件位置：在mousemove事件中，根据鼠标指针的位置和之前计算的偏移量，动态更新组件元素的位置。
结束拖拽：在mouseup事件中，结束拖拽状态，并可能触发一些额外的逻辑，如组件位置的保存或界面布局的重新计算
#### 移动端事件 touch 与 PC 上的 click 有什么区别？touch 会遇到什么问题？
pc端/移动端的click事件定义是手指触摸到屏幕开始，并在300ms内离开屏幕且这段时间内手指不能移动，此时可以认为发生了一次移动端的点击事件。
touch和click的执行顺序：touchstart-> touchmove->touchend <==> 等价于click事件
如何只触发touch事件，但是不触发click事件？使用preventDefault()方法阻止冒泡
#### 假如一个页面 onload 了，用户点击页面的按钮的时候并发请求了三个请求，此时 浏览器与服务器建立多少个什么连接
HTTP 1.1：浏览器可能会建立 1 到 3 个 TCP 连接，具体数量取决于持久连接和连接复用情况。
HTTP 2：浏览器通常只需要建立一个 TCP 连接来处理所有请求。
#### 如何高效地从 1000 个 div 中删除 10 个 div
Document Fragment:
减少了对 DOM 的多次操作，将需要删除的元素暂时存储在 Document Fragment 中，一次性从 DOM 中删除。
推荐用于批量操作，减少性能开销。
先移出视图再删除:
先将元素隐藏，再进行删除，可以减少 DOM 重绘次数。
适用于需要在用户界面上无缝操作的场景。
#### 60 个请求（限制最多同时请求 6 个）请求并行方案
使用 for...of 循环遍历每个 URL，创建一个异步请求，并将其 Promise 存储在 executing 数组中。
如果 executing 数组的长度达到了 maxConcurrent，则使用 Promise.race 等待其中一个请求完成，并从 executing 数组中移除它。
最后，使用 Promise.all 等待所有剩余的请求完成，并返回结果。
#### 如何设计一个本地存储的包 提供给其他同事用， 思路、实现细节
设计思路
统一接口：提供一致的API，简化本地存储的使用。支持基本的增、删、查、改操作。
数据类型支持：支持字符串、对象、数组等多种数据类型的存储和读取。
数据过期管理：可以设置存储数据的有效期。
错误处理：提供必要的错误处理机制，确保在存储或读取失败时能够处理异常。
包管理：提供良好的模块化支持，方便通过npm等包管理工具使用。
#### 有50g 的 QQ 号数据，一次只能运行 20g，想要找出出现次数最多的前十个 qq 号，怎么做？
1. 数据拆分将 50GB 的数据分成三部分，每部分 20GB，处理时一次读取一部分。
2. 处理每一部分对于每个 20GB 的数据，统计其中每个 QQ 号的出现次数，并将中间结果存储起来。
3. 合并结果将三部分中间结果合并，并最终找出出现次数最多的前十个 QQ 号。
#### 发送验证码功能，向同一个手机发送多次验证码（攻击），怎么处理
1. 实施验证码发送限制
   限制发送频率：限制同一手机号在一段时间内可以请求验证码的次数。例如，限制每分钟或每小时最多发送几次。
   验证码有效期：确保验证码有有效期限制，过期后需要重新生成。
   IP 地址限制：如果可能的话，限制同一 IP 地址发送验证码的频率，以防止通过多个虚拟号码向同一手机号发送攻击。
2. 添加人机验证
3. 使用安全验证码服务第三方服务：考虑使用专业的验证码服务提供商（如阿里云、腾讯云等），他们通常有防范验证码滥发攻击的机制，如智能识别异常行为、限制频率等。
4. 监控和分析异常行为异常行为监控：实时监控验证码发送请求，检测并分析异常行为，如短时间内大量请求、频繁更换手机号码等。反欺诈系统：考虑实施反欺诈系统，能够自动识别并阻止恶意攻击行为。
5. 强化安全意识和教育用户教育：通过应用或网站页面提醒用户注意保护个人信息安全，防止个人信息被泄露或滥用。
6. 处理异常情况异常处理：如果检测到异常行为，例如频繁发送验证码，可以暂时性地封禁发送请求的 IP 地址或手机号码，以阻止进一步的攻击。
#### 很大的日志读取，ip 出现最多的十次，怎么分片
日志分片逐行读取日志文件，统计每个 IP 地址的出现次数。借助最小堆记录前10个出现最多的ip
#### 如果要实现在离线情况下编辑且不丢失数据，怎么办？
实现在离线情况下编辑且不丢失数据的功能通常涉及到将数据在本地进行缓存和同步的技术。以下是一些常见的实现方式和建议：
1. 使用本地存储技术
2. LocalStorage / SessionStorage
3. 应用状态管理工具
4. 数据同步和持久化策略,当检测到网络恢复时，将本地缓存的数据同步到远程服务器。冲突解决在更新数据时，检查数据的版本号或时间戳，避免同时编辑造成的数据冲突,合并策略：实现合并算法，自动合并或者提供用户手动解决冲突的界面。
#### 微信附近的人这个功能，如何设计
用户授权定位：用户打开微信附近的人功能，系统请求获取用户的位置信息，并经过用户授权后获取。
位置信息存储：将用户位置信息存储在后端服务器中，通过地理位置索引技术加速数据检索。
显示附近用户：根据用户位置信息，查询并显示附近用户的头像和基本信息，可选择在地图上或列表中展示。
隐私设置：用户可以在设置中选择是否对位置信息进行公开，以及公开的精确度和显示方式。
安全措施：保证用户位置信息的安全性和隐私保护，防止未经授权的访问和滥用。
#### 如何实现一个可编辑的可以无限延伸的表格？
就是使用一个可编辑表格组件，点击按钮添加一行，也可以删除
#### 前端要加载一个图片有哪些方式，然后还问到了 icon 是怎么实现的
加载方式如下：
通过 URL 加载图片
通过 Base64 数据加载图片
通过 CSS 背景图片加载
通过 JavaScript 动态加载
icon如下：
字体图标（Font Icons）
SVG 图标
CSS Sprite
#### 假如说我们的网页有一个表单，有人模拟 http 的 post 绕过了表单将数据发送到了后台应该怎么办
1. CSRF 是一种攻击方式，利用用户已登录的身份在用户不知情的情况下发送恶意请求，使用token预防，设置cookie的samesite属性
2. 输入验证和过滤
3. 后端验证和授权
4. https的使用
5. 安全审计与漏洞检查
6. 日志和监控，监控用户行为包括异常行为
#### vue 中如何渲染用户想要的自定义文本，比如有各种颜色，各种字体大小(类似于用 vue 实现一个文本编辑器）
使用双向数据绑定就行了
#### sso 单点登录流程
登录流程：
用户访问应用 A，应用 A 发现用户未登录，重定向到认证中心进行登录。
用户在认证中心输入用户名密码进行认证。
认证中心验证成功后，生成会话令牌，并返回给应用 A。
应用 A 使用会话令牌验证用户身份，允许用户访问。
用户访问应用 B，应用 B 发现用户已有有效会话，无需重新登录，直接允许访问。
注销流程：
用户在任意一个应用注销登录，应用通知认证中心使其失效所有相关会话令牌。
认证中心清除用户的会话信息，确保用户在所有应用中都需要重新登录。
#### 扫码登录怎么做，手机端和 PC 端都要建立长连接吗？
手机端
实现扫码登录可以通过简单的请求和响应机制（轮询）来完成，手机端和 PC 端不需要建立长连接。
生成二维码：在手机端生成一个唯一的二维码，包含一个标识符（如随机生成的 token）。
展示二维码：将生成的二维码展示给用户，等待用户扫码。
轮询扫码状态：手机端开始轮询登录端的服务器，检查用户是否已经扫描并确认了登录操作。
用户确认：用户在扫码端扫描二维码，并确认登录操作。
通知登录状态：一旦用户确认登录，扫码端向登录端的服务器发送确认消息。
pc端
接收二维码：登录端从扫码端获取到二维码，并展示给用户。
等待用户扫描：登录端等待用户扫描二维码并确认登录操作。
处理登录请求：一旦用户扫描并确认登录，登录端的服务器接收到确认消息。
建立会话：登录端服务器验证扫码端发送的确认消息，根据验证结果建立用户会话，完成登录流程。
#### 说一下 token 和 cookie 登录的区别
token工作方式：
客户端（通常是前端应用）在用户登录成功后，从服务器获取 Token。
Token 存储在客户端（如 localStorage 或 sessionStorage）中，并在每次请求时包含在 HTTP 请求头或 URL 的查询参数中。
服务器验证 Token 的有效性，并根据 Token 中的信息进行用户身份认证和授权。
cookie工作方式：
用户登录后，服务器在响应中设置一个包含 Session ID 的 Cookie。
浏览器会在每次请求中自动将 Cookie 发送到服务器，服务器根据 Session ID 来识别用户会话。
服务器端存储了与 Session ID 相关的用户信息，可以跟踪用户的登录状态和会话数据。
区别：
存储位置：Token 存储在客户端，通常是在 localStorage 或 sessionStorage 中；Cookie 存储在客户端的 Cookie 文件中。
安全性：Token 可以通过签名进行保护，安全性较高；Cookie 需要额外的安全措施来防范攻击。
跨域支持：Token 更容易在跨域场景中使用；Cookie 受同源策略限制。
无状态特性：Token 无状态，适合分布式系统和 API 调用；Cookie 有状态，需要服务器端维护会话状态。
#### 浏览器保存用户账号密码的原理是什么
浏览器保存用户账号密码的原理是通过密码管理器安全地加密和存储用户的登录凭据，以及通过自动填充机制在用户访问相同网站时自动填充保存的用户名和密码。这种机制旨在提高用户体验的同时，也要确保密码信息的安全性和保护用户隐私。
#### 如何实现一个进度条动画？
定义一个进度条容器和进度条元素。
设置容器和进度条的基本样式，包括宽度、高度、颜色等。
编写一个函数，通过定时器逐步增加进度条的宽度，实现动画效果。
#### 做过哪些公共组件？DatePicker 怎么实现的？难点在哪里？
组件结构设计
输入框（Input Field）：用于显示选定的日期，并触发日期选择界面的显示和隐藏。
日期选择界面（Calendar Pop-up）：包含月份导航、日期显示区域和可能的快捷选项。
基本功能：
显示和隐藏日期选择界面。
在日历上选择一个日期。
显示当前选定的日期。
导航至上一个月和下一个月。
支持不同日期格式。
扩展功能：
支持时间选择（时间选择器）。
支持日期范围选择（开始日期和结束日期）。
支持禁用特定日期（如过去的日期或假期）。
多语言和本地化支持。
用户交互设计
点击输入框：显示日期选择界面。
点击日期选择界面外部区域：隐藏日期选择界面。
选择日期：更新输入框中的日期并隐藏日期选择界面。
点击导航按钮：更新当前显示的月份。
键盘操作：使用箭头键导航日期，回车键选择日期。
#### 组件封装有哪些原则？
单一职责，可复用，可组合，可配置，无副作用，文档注释，可测试
#### 组件数据和 UI 怎么分离？
容器组件（Container Components）：负责管理数据逻辑，包括状态管理、数据获取和事件处理。容器组件不负责 UI 渲染。
展示组件（Presentational Components）：只负责 UI 渲染，通过 props 接收数据和事件处理函数，不包含业务逻辑。
#### 如何开发一个 tree 组件，思路，注意的点
1. 梳理需求
   展示嵌套的层级结构数据。
   支持节点的展开和收缩。
   支持节点的选择（单选或多选）。
   支持节点的添加、删除、修改。
   支持节点的拖拽排序（可选）。
   支持自定义节点样式和内容。
   支持异步加载子节点（可选）
2. 设计数据结构
```
[
  {
    "id": 1,
    "label": "Node 1",
    "children": [
      {
        "id": 2,
        "label": "Node 1.1",
        "children": []
      }
    ]
  },
  {
    "id": 3,
    "label": "Node 2",
    "children": []
  }
]
```
3. 组件结构设计
   Tree：主组件，负责渲染整个树形结构。
   TreeNode：节点组件，负责渲染每个节点及其子节点。
4. 状态管理
   组件需要管理的状态：
   节点的展开/收缩状态。
   选中节点的状态。
   异步加载状态（如果有）。
5. 注意点
   性能问题
   递归渲染
   鼠标键盘事件
   可访问性
   样式的定义
   异步加载
#### 如何开发一个 select 组件 ，类似百度输入框功能，需要考虑的点有哪些
1. 确定需求和功能
   用户可以在输入框中输入内容。
   根据用户输入实时过滤选项。
   支持异步加载选项（例如从服务器获取数据）。
   支持键盘导航（上下箭头选择，高亮显示选项，回车键选择）。
   支持鼠标选择选项。
   支持自定义选项渲染。
   支持多选（可选）。
   支持输入框失焦时关闭选项列表。
2. 组件结构设计
   Input：用户输入的文本框。
   Dropdown：展示过滤后的选项列表。
   Option：每个单独的选项。
3. 注意点
   性能优化：在输入变化时进行防抖处理，避免频繁请求和渲染。优化长列表渲染，使用虚拟列表技术。
   异步数据加载：在用户输入时异步获取数据，并在数据返回后更新选项列表。处理异步请求的取消和错误。
   键盘和鼠标事件处理：支持键盘导航和选择。鼠标点击选项时选择该选项并关闭下拉列表。
   用户体验：输入框失焦时关闭选项列表。提供加载指示器和无匹配结果的提示。支持清除输入框内容的功能。
   样式和自定义：提供灵活的样式定制方案，允许用户通过 props 传入自定义样式。 支持选项的自定义渲染。
#### 如果需要你实现一个弹幕的组件，你需要如何设计这个组件的 props 和 state，内部如何实现，有哪些地方可以优化
Props
data: 弹幕的数据，通常是一个数组，每个元素包含弹幕的内容、颜色、字体大小等信息。
duration: 弹幕从出现到消失的持续时间。
speed: 弹幕的移动速度。
limit: 屏幕上最多同时显示的弹幕数量。
onSend: 发送新弹幕的回调函数。
State
visibleDanmus: 当前正在显示的弹幕数组。
queueDanmus: 等待显示的弹幕数组，用于存放尚未进入屏幕显示区域的弹幕。
内部实现
1. 初始化
   在组件加载时，初始化 visibleDanmus 和 queueDanmus 状态。
2. 弹幕管理
   使用定时器或 requestAnimationFrame 控制弹幕的出现和移动。
   根据 duration 和 speed 控制弹幕的动画效果。
3. 弹幕显示逻辑
   控制屏幕上同时显示的弹幕数量，超过 limit 的弹幕放入 queueDanmus 中等待显示。
   根据屏幕尺寸和弹幕内容计算弹幕的位置，避免弹幕重叠或者超出屏幕范围。
4. 弹幕发送
   外部通过 onSend 回调函数发送新的弹幕数据。
   将新的弹幕数据加入 queueDanmus，等待下一次显示。
5. 用户交互
   可能需要支持暂停、继续、清除弹幕的功能。
   提供 API 让用户可以控制弹幕的显示和隐藏。
   优化点
   性能优化
   使用虚拟列表技术管理大量弹幕的渲染，避免一次性渲染过多 DOM 元素。
   合理使用 CSS 动画或者 requestAnimationFrame 控制弹幕的流畅移动。
   数据结构优化
   使用队列管理弹幕的显示和移动，确保动画流畅性和显示效果。
   响应式设计
   支持不同屏幕尺寸下的弹幕显示，保证弹幕不被遮挡或者超出屏幕范围。
   可配置性
   提供灵活的 props，允许用户自定义弹幕的样式、速度、显示方式等参数。
   用户体验
   支持弹幕的暂停、清除、隐藏等功能，提升用户交互体验。
#### 说一下，实现一个 toast（提示框）函数的大致思路
1. 设计 Props
   message: 提示信息的内容。
   duration: 提示框显示的持续时间。
   type: 提示框的类型，例如成功、警告、错误等，决定不同的样式。
   position: 提示框的显示位置，可以是页面的某个角落。
   onClose: 提示框关闭时的回调函数，用于清理操作或执行额外的逻辑。
2. 创建 DOM 元素
   动态创建一个包含提示信息的 DOM 元素，并设置其样式和内容。
3. 插入到页面中
   将创建的提示框 DOM 元素插入到页面中的指定位置，通常是 document.body 的子节点。
4. 控制显示和隐藏
   使用 CSS 动画或者 JavaScript 控制动画，使提示框以一定的动画效果（如淡入淡出、从上方滑入等）显示在页面上。
   设定一定的显示时间后自动隐藏提示框，或者提供关闭按钮供用户手动关闭。
5. 多个提示框处理
   如果需要支持多个提示框同时存在，需要考虑如何管理多个提示框的显示和隐藏，避免重叠或遮挡。
6. 性能优化
   考虑在动画结束后从 DOM 中移除提示框，以节省资源和提升性能。
   在多次调用 toast 函数时，避免频繁创建和销毁 DOM 元素，可以使用对象池或者复用已有的 DOM 元素来优化性能。
#### 现在要你完成一个 Dialog 组件，说说你设计的思路？它应该有什么功能？
1. 定义 Props
   visible: 控制对话框的显示和隐藏。
   title: 对话框的标题。
   content: 对话框的内容，可以是文本或者其他组件。
   footer: 对话框底部的内容，通常是操作按钮或者其他交互元素。
   closable: 是否显示关闭按钮。
   onClose: 关闭对话框时的回调函数。
   width: 对话框的宽度。
   maskClosable: 是否点击遮罩层关闭对话框。
2. 设计 State
   visible: 控制对话框的显示和隐藏状态。
   其他状态如动画效果、定位等可以根据需要设计。
3. 内部实现
   遮罩层: 控制点击遮罩层关闭对话框的行为。
   动画效果: 使用 CSS 过渡或者动画库（如 react-transition-group）实现对话框的动画效果，比如淡入淡出、从中心扩展等。
   样式定制: 提供灵活的样式定制方案，允许用户通过 props 传入自定义样式。
4. 用户交互
   关闭按钮: 如果 closable 属性为 true，则显示关闭按钮，并绑定关闭事件。
   底部操作: 将传入的 footer 渲染在对话框底部，可以是操作按钮或其他交互元素。
   键盘操作: 支持键盘操作，比如按下 Esc 键关闭对话框。
5. 性能优化
   懒加载: 对话框组件的内容可以进行懒加载，只有在对话框显示时再渲染内容。
   动画优化: 合理使用 CSS 动画或者使用硬件加速优化动画效果，避免页面卡顿。
   内存管理: 对于大型内容或者频繁打开关闭的场景，确保及时清理和释放资源。
#### 组件升级怎么让使用这个组件的人都知道。
1. 文档更新
   README 文件: 如果你的组件库有一个 README 文件，确保在文件中更新升级后的内容。包括新功能、修复的 bug、不兼容变化以及如何升级到新版本的说明。
   在线文档: 如果你有在线文档（如官方网站或者文档页面），及时更新文档以反映新版本的变化。
2. 版本号管理
   使用语义化版本号（Semantic Versioning），确保升级时的版本号变化能够反映出重要的变化。例如，主版本号变更通常表示不兼容的 API 变化，次版本号变更表示向后兼容的新功能添加，补丁版本号变更表示向后兼容的 bug 修复。
3. 发布通知
   如果可能的话，在社区或者组件库的发布平台（如 npm、GitHub Releases）发布通知或者发布说明，告知用户有关升级内容的重要信息。
   可以通过发布公告、邮件通知等方式向用户群体传达升级信息。
4. 向后兼容性
   尽可能保持向后兼容性，避免不必要的破坏性变更，这样用户在升级时可以更加顺利。
5. 示例和演示
   如果你的组件有示例或者演示页面，确保更新演示以展示新版本的功能和变化。这有助于用户理解新特性和如何使用它们。
6. 社区和反馈
   如果可能，定期检查社区的反馈和问题，确保用户没有遇到重大问题或者不明确的地方。及时响应和解决可能出现的问题。
7. API 文档
   更新 API 文档以反映新版本的 API 更改或者添加。确保用户可以准确地查找和使用新的 API。
8. 更新日志
   在更新日志中记录每个版本的变更和修复。这有助于用户了解到每个版本的具体变化和改进。
#### 如果让你设计项目自动设计组件升级，并且安全，你会怎么去设计
自动检测更新：定期或者实时检测组件库的新版本发布。
安全验证：验证版本发布的签名或哈希值，确保版本的完整性和安全性。
自动通知：向开发者或者相关团队发送更新通知。
自动化测试：运行自动化测试套件，确保新版本的兼容性和稳定性。
灰度发布：根据设定的策略，逐步向用户发布新版本。
监控和回滚：监控新版本的性能和稳定性，及时回滚到上一个版本以应对问题。
#### 写一个翻页的插件需要哪些注意的参数
必要参数
total: 总页数或者总数据条目数。这个参数决定了翻页插件需要展示多少页码或者控制总共有多少页。
currentPage: 当前页码。用于标识当前处于哪一页，插件应该高亮显示或者激活该页码。
pageSize: 每页显示的数据条目数量。这个参数影响到翻页的行为，如计算总页数、跳转到某一页时的偏移量等。
可选参数
showSizeChanger: 是否显示每页条目数的切换器（比如可以选择每页显示 10、20、50 条数据）。
pageSizeOptions: 如果显示每页条目数切换器，这个参数定义了可选的每页条目数选项列表。
onChange: 当页码发生变化时的回调函数。可以用于处理页码切换时加载数据、更新 UI 状态等操作。
onShowSizeChange: 当每页显示条目数量发生变化时的回调函数。用于处理每页条目数变更时重新加载数据等操作。
showQuickJumper: 是否显示快速跳转输入框，允许用户直接输入页码跳转。
showTotal: 是否显示总条目数信息，通常用于显示总数据量和当前数据范围。
itemRender: 自定义页码或者上一页、下一页按钮的渲染方式，允许用户根据需求自定义按钮样式或者添加图标等。
simple: 是否使用简单模式显示页码，简单模式通常只有上一页、下一页按钮和快速跳转输入框，不显示具体的页码按钮。
#### 文件上传的二进制具体是怎么处理的
1. 客户端（浏览器）端处理
   选择文件: 用户通过页面上的文件选择框选择要上传的文件。
   读取文件内容: 浏览器使用 FileReader 或者类似的 API，将选择的文件转换成二进制数据（Blob 对象或 ArrayBuffer）。
   数据切片（分块）: 如果文件较大，浏览器可能会将文件切分成多个小块（Chunk），每个块的大小通常受到浏览器和服务器的限制。
   上传准备: 将文件的二进制数据准备好，通常在上传之前可能需要添加一些元数据，比如文件名、文件类型等信息，这些信息会作为请求的一部分。
   发送请求: 使用 XMLHttpRequest 或者 fetch API 发送 POST 请求到服务器。请求的内容包括文件的二进制数据以及其他相关信息（如文件名、文件类型等）。
2. 服务器端处理
   接收请求: 服务器端接收到包含文件二进制数据的 POST 请求。
   解析请求: 根据服务器端框架或者自定义逻辑，解析请求体，提取文件的二进制数据。
   存储文件: 将接收到的二进制数据存储到服务器的文件系统、数据库或者对象存储服务中。存储方式取决于具体的应用需求和服务器架构。
   处理文件: 可能会对文件进行进一步的处理，如生成缩略图、校验文件格式、存储文件元数据等。
   响应客户端: 将上传成功或失败的状态信息以及其他需要返回的数据发送回客户端，以便客户端可以根据响应进行相应的处理。
   注意事项
   安全性: 文件上传涉及到安全风险，需要在服务器端做好文件类型验证、大小限制、防止文件包含攻击等安全措施。
   性能优化: 对于大文件，可以考虑使用分片上传和断点续传技术，以提升上传效率和用户体验。
   进度监控: 可以实现上传进度的监控，让用户了解文件上传的进度和状态。
#### 大文件上传如何做断点续传？
1. 文件切片（Chunking）
   将大文件切分成多个小块（chunk），每个块的大小通常在几百 KB 到几 MB 之间。切片的大小不仅取决于服务器和客户端的性能，还应该考虑网络环境和数据传输的稳定性。
2. 上传和保存断点信息
   前端（客户端）处理：
   客户端上传每个切片，并将每个切片的上传进度记录下来。
   将已上传的切片信息发送给服务器，以便服务器知道哪些部分已经上传。
   后端（服务器端）处理：
   接收客户端发送的切片数据，并将每个切片存储在服务器上的临时位置。
   保存每个切片的上传状态和位置信息，通常使用数据库或者文件系统记录已上传的切片信息。
3. 合并切片（合并上传）
   前端（客户端）处理：
   当所有切片都成功上传后，向服务器发送一个合并请求，请求服务器将所有切片合并成完整的文件。
   如果上传过程中失败或用户中断上传，用户可以重新上传未完成的切片。
   后端（服务器端）处理：
   收到合并请求后，服务器根据保存的切片信息将所有切片按顺序合并成完整的文件。
   验证合并完成的文件的完整性和正确性。
4. 断点续传的优化和注意事项
   并发和并行处理：允许同时上传多个切片或者使用多线程/多进程处理上传，以提高上传速度和效率。
   上传状态管理：确保上传状态的一致性和可靠性，包括处理上传中断、超时和网络错误等情况。
   上传进度显示：实现上传进度的实时更新和显示，让用户可以清楚地了解文件上传的进度。
   安全性考虑：对上传文件的类型、大小和内容进行验证和检查，防止恶意文件或者非法内容的上传。
   技术选型和工具
   前端：通常使用 JavaScript 和 HTML5 提供的 File API 和 Blob API 进行文件切片和上传。
   后端：服务器端可以使用 Node.js、Java、Python 等语言和框架处理文件上传和切片合并的逻辑。
   存储：文件切片可以暂时存储在服务器的文件系统中，也可以存储在云存储服务（如 AWS S3、Azure Blob Storage）中。
#### 怎么实现下载的功能
后端（服务器端）
文件存储和管理：
确保服务器端存储了要下载的文件，可以是在文件系统中或者数据库中。
文件应该能够通过唯一标识符（如文件名、ID等）进行定位和检索。
下载请求处理：
设计一个后端接口（如 /download），接收客户端的下载请求。
接口应该能够解析请求中的文件标识符（如文件名），找到对应的文件。
响应设置：
设置响应的 Content-Type 头部，确保浏览器能够正确解析文件类型（如 application/octet-stream 用于通用二进制文件）。
设置 Content-Disposition 头部，指定文件的下载行为，如 attachment; filename=filename.txt 表示下载并指定文件名为 filename.txt。
文件传输：
从文件系统或者数据库中读取文件内容，创建一个流（Stream）或者缓冲区，并将文件内容传输给响应对象。
对于大文件，使用流可以避免将整个文件内容加载到内存中，提高性能和效率。
错误处理：
在文件不存在或者下载失败时，返回适当的 HTTP 状态码（如 404 Not Found）和错误消息给客户端。
前端（客户端）
发起下载请求：
使用浏览器的内置功能（如 <a> 元素的 download 属性、fetch API 或者 XMLHttpRequest 对象）来发起下载请求。
构建合适的下载链接（URL），传递文件标识符（如文件名）作为参数。
处理响应：
当接收到下载响应时，浏览器会根据响应的 Content-Type 自动处理文件的下载和保存，弹出文件保存对话框。
如果使用 JavaScript 发起下载请求，通常会创建一个隐藏的 <a> 元素，设置其 href 属性为下载链接，通过模拟点击来触发文件下载动作。
用户交互：
提供良好的用户体验，如在下载进行时显示进度条或者下载状态，以及适当的反馈信息。
考虑到可能的下载失败情况（如网络中断），可以实现重新下载或者错误处理机制。