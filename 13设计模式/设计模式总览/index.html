<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>设计模式总览</title>
  <style>
    .content{
      padding: 0 10px;
    }
    .box{
      width: 25%;
      min-width: 300px;
      float: left;
      height: 200px;
      border: 1px solid #ddd;
      padding: 6px;
      box-sizing: border-box;
    }
    .box-header{
      overflow: auto;
      height: 76px;
    }
    .box-header-img{
      width: 100px;
      float: left;
    }
    .box-header-content{
      float: left;
      margin-top: 10px;
      margin-left: 10px;
    }
    .box-header-content-title{
      font-size: 22px;
      font-weight: 700;
    }
    .box-header-content-titleEn{
      font-style: italic;
    }
    .box-content{
      padding: 6px;
    }
    .clear{
      clear: both;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/vue@2"></script>
</head>
<body>
<div id="app">
  <h2>设计模式</h2>
  <div class="content">
    <h4>设计模式的7大原则</h4>
    <p>1. 开闭原则（Open Closed Principle，OCP）：对扩展开放，对修改关闭，增加功能扩展代码而非修改代码。</p>
    <p>2. 单一职责原则（Single Responsibility Principle, SRP）：一个类只干一件事，功能复杂就拆分。</p>
    <p>3. 最少知识原则（Least Knowledge Principle，LKP）或者迪米特法则（Law of  Demeter，LOD）：一个类应当尽可能少的与其他类发生相互作用。</p>
    <p>4. 里氏代换原则（Liskov Substitution Principle，LSP）：子类可以扩展父类的功能，但不能改变父类原有的功能。</p>
    <p>5. 合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）：尽量使用合成/聚合的方式，而不是使用继承。</p>
    <p>6. 依赖倒转原则（Dependency Inversion Principle，DIP）：依赖于抽象而不依赖于具体。</p>
    <p>7. 接口隔离原则（Interface Segregation Principle，ISP）：保持接口的单一独立，实现接口的类中，有多余的方法时，需要将接口进行拆分。</p>
  </div>
  <div class="content">
    <h4>各种设计模式概览</h4>
    <h4>创建型：提供了创建对象的机制， 能够提升已有代码的灵活性和可复用性。</h4>
    <div class="box" v-for="item in obj" :key="item.nameEn">
      <div class="box-header">
        <img class="box-header-img" :src="item.url" width="100px">
        <div class="box-header-content">
          <div class="box-header-content-title">{{item.name}}</div>
          <div class="box-header-content-titleEn">{{item.nameEn}}</div>
        </div>
      </div>
      <div class="box-content">
        {{item.content}}
      </div>
    </div>
    <div class="clear"></div>
    <h4>结构型：如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。</h4>
    <div class="box" v-for="item in obj2" :key="item.nameEn">
      <div class="box-header">
        <img class="box-header-img" :src="item.url" width="100px">
        <div class="box-header-content">
          <div class="box-header-content-title">{{item.name}}</div>
          <div class="box-header-content-titleEn">{{item.nameEn}}</div>
        </div>
      </div>
      <div class="box-content">
        {{item.content}}
      </div>
    </div>
    <div class="clear"></div>
    <h4>行为型：行为模式负责对象间的高效沟通和职责委派。</h4>
    <div class="box" v-for="item in obj3" :key="item.nameEn">
      <div class="box-header">
        <img class="box-header-img" :src="item.url" width="100px">
        <div class="box-header-content">
          <div class="box-header-content-title">{{item.name}}</div>
          <div class="box-header-content-titleEn">{{item.nameEn}}</div>
        </div>
      </div>
      <div class="box-content">
        {{item.content}}
      </div>
    </div>
  </div>
</div>

<script>
  let app = new Vue({
    el: '#app',
    data: {
      obj : [
        {
          name: '简单工厂',
          nameEn: 'Simple Factory',
          content: '小作坊，适用于少量对象的创建，集中式管理，使用简单、扩展不便。',
          url: './img/simple-factory.png',
        },
        {
          name: '工厂方法',
          nameEn: 'Factory Method',
          content: '正规小工厂，每种产品一个独立工厂，偏平化扩展。',
          url: './img/factory-method.png',
        },
        {
          name: '抽象工厂',
          nameEn: 'Abstract Factory',
          content: '集团化大厂，产品种类、层级众多，需要多层级的工厂来管理。',
          url: './img/abstract-factory.png',
        },
        {
          name: '建造者',
          nameEn: 'Builder',
          content: '使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。',
          url: './img/builder.png',
        },
        {
          name: '原型',
          nameEn: 'Prototype',
          content: '让你能够复制已有对象，而又无需使代码依赖它们所属的类。',
          url: './img/prototype.png',
        },
        {
          name: '单例',
          nameEn: 'Singleton',
          content: '让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。',
          url: './img/singleton.png',
        }
      ],
      obj2 : [
        {
          name: '适配器',
          nameEn: 'Adapter',
          content: '让接口不兼容的对象能够相互合作。',
          url: './img/adapter.png',
        },
        {
          name: '桥接',
          nameEn: 'Bridge',
          content: '可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用。',
          url: './img/bridge.png',
        },
        {
          name: '组合',
          nameEn: 'Composite',
          content: '你可以使用它将对象组合成树状结构，并且能像使用独立对象一样使用它们。',
          url: './img/composite.png',
        },
        {
          name: '装饰',
          nameEn: 'Decorator',
          content: '允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。',
          url: './img/decorator.png',
        },
        {
          name: '外观',
          nameEn: 'Facade',
          content: '能为程序库，框架或其他复杂类提供一个简单的接口。',
          url: './img/facade.png',
        },
        {
          name: '享元',
          nameEn: 'Flyweight',
          content: '摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，让你能在有限的内存容量中载入更多对象。',
          url: './img/flyweight.png',
        },
        {
          name: '代理',
          nameEn: 'Proxy',
          content: '让你能够提供对象的替代品或其占位符，代理控制着对于原对象的访问。并允许在将请求提交给对象前后进行一些处理。',
          url: './img/proxy.png',
        }
      ],
      obj3 : [
        {
          name: '模板方法',
          nameEn: 'Template Method',
          content: '在超类中定义一个算法的框架，允许子类在不修改结构的情况下重写算法的特定步骤。',
          url: './img/template-method.png',
        },
        {
          name: '责任链',
          nameEn: 'Chain of Responsibility',
          content: '允许你将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。',
          url: './img/chain-of-responsibility.png',
        },
        {
          name: '备忘录',
          nameEn: 'Memento',
          content: '允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。',
          url: './img/memento.png',
        },
        {
          name: '中介者',
          nameEn: 'Mediator',
          content: '能让你减少对象之间混乱无序的依赖关系。该模式会限制对象之间的直接交互，迫使它们通过一个中介者对象进行合作。',
          url: './img/mediator.png',
        },
        {
          name: '观察者',
          nameEn: 'Observer',
          content: '允许你定义一种订阅机制，可在对象事件发生时通知多个“观察”该对象的其他对象。',
          url: './img/observer.png',
        },
        {
          name: '访问者',
          nameEn: 'Visitor',
          content: '将算法与其所作用的对象隔离开来。',
          url: './img/visitor.png',
        },
        {
          name: '状态',
          nameEn: 'State',
          content: '让你能在一个对象的内部状态变化时改变其行为，使其看上去就像改变了自身所属的类一样。',
          url: './img/state.png',
        },
        {
          name: '策略',
          nameEn: 'Strategy',
          content: '能让你定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够相互替换。',
          url: './img/strategy.png',
        },
        {
          name: '命令',
          nameEn: 'Command',
          content: '它可将请求转换为一个包含与请求相关的所有信息的独立对象。该转换让你能根据不同的请求将方法参数化、延迟请求执行或将其放入队列中，且能实现可撤销操作。',
          url: './img/command.png',
        },
        {
          name: '迭代器',
          nameEn: 'Iterator',
          content: '让你能在不暴露集合底层表现形式（列表、栈、树等）的情况下遍历集合中所有的元素。',
          url: './img/iterator.png',
        },
        {
          name: '解析器',
          nameEn: 'Interpreter',
          content: '将每个文法规则表示为一个类，通过组合这些规则的对象来解释表达式。',
          url: './img/interpreter.png',
        }
      ]
    }
  })

</script>
</body>
</html>
